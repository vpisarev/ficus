(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Converts K-form into C-form (see c_form.ml).
    We assume that K-form has been prepared for the conversion,
    i.e. lambda lifting has been done, all the complex
    data structures, such as records, tuple, lists etc. have
    been converted to KTypName(...) etc.

    The algorithm:
        1. do the 1st pass through the K-form, convert all the types and exceptions (see c_gen_types.ml).
        2. do the 2nd pass through the K-form, generate headers for all the functions (see c_gen_fdecls.ml):
            - each function, except for the constructors, gets extra "free variables"/"closure data"
              parameter fx_fv, even if it's not used.
            - the return value becomes the output parameter fx_result (before the closure pointer), unless
              the function is "nothrow" and the return type is scalar.
            - the non-"nothrow" function gets "int" return value, the status.
              "nothrow" functions return the result or return "void".
        3. do the 3rd pass through the K-form:
            - convert body of each function to C-form
            - put all the global calculations to a dedicated function fx_toplevel();
              all the intermediate values, used at the global scope, are moved to this function as well.
            - collect all the global c-code fragments into a dedicated list
        4. output the final C code as concatenation of the following parts (in this particular order):
            - preamble (some general comment about autogenerated file + #include "ficus/ficus.h")
            - all the global c code
            - forward declarations of some types and their destructors
            - declarations of all the types and their helper functions (constructors, destructors, copy operators)
            - declarations of all the exceptions and their constructors
            - declarations of the global variables together with their default initializers.
            - forward declarations of some functions
            - declarations and definitions of all the functions
            - the function "int fx_toplevel(void) {...}"
            _ the function main() that initializes runtime, calls fx_toplevel() and returns its value.

    The K-form to transform as a recursive tree of expressions.
    So we call kexp2cexp recursively to convert K expression to C code. The function
    takes kexp_t on input and returns a pair of (cexp_t, cstmt_t list) on output.
    The first output value is equivalent C expression or name of variable that stores it.
    The second output value is reversed list of C statements, new statements are added into the begining,
    because it's O(1) operation. In the end of each block we reverse the list and form block statement
    (loop body, if branch, function body etc.)

    We maintain and recursively pass the following compiler state:
    - C code generated so far. Just like in k_normalize.ml, this is the reverse list of c statements.
      It's passed as input to many code generation functions that update it and return.
    - The "catch" label stack. In the beginning of new function we push the default "cleanup" label
      for that function and pop in the end. We also push-pop a new label when we translate
      try {} catch {} block. In principle, we can use dedicated catch labels in some other nested statements,
      like for(), if() etc. For simplicity we do not do that, at the expense of slightly higher
      overhead imposed by the single big cleanup section per function. After we employ the inline function
      call optimization, the relative overhead of the cleanup sections should decrease.
      In the catch blocks we jump to the underlying label in the stack,
      thus providing the exception propagation mechanism.
    - the map of id->cexp_t pairs (i2e); not passed as argument, but maintained separately.
      It does not make sense to represent all the values in K form as C variables.
      If the value (id) is:
      1. used just once
      2. immutable (val, not var)
      3. a result of pure expression, which operands are also values
      then the id can be just replaced with the expression in C-form.
    - the stack of scopes where we need to do some cleanup:

      global -> [fun -> ] [try -> ] [for/while/do-while ->] [match case ->] ...

    - reference to the destination expression, or ref None.
        - when the translated kexp_t has type KTypVoid, no output value is needed.
        - in some other cases, there is no pre-defined target for expression.
          Then we need to generate a new temporary value and store the result there.
          Or even postpone the temporary value assignment and put the pair (id, cexp) to the map.
        - in some cases we are given the pre-defined expression target.
        - for example, the function body expression result should be stored in fx_result.
        - When we have K-form code "var x=val0; ... x=new_val;", new_val should be stored in x,
          no need to generate a temporary value, because we want to avoid unnecessary data copying.
          So, we pass x as the target location when we convert `new_val` to C code.
        - "record.f = new_val", "arr[idx] += newval" etc. are other such cases. In those cases we
          use a TEMP_REF val that is the pointer to the proper record field or array element.
          However, in those cases we will try to generate idiomatic C code, e.g. "record.f = new_val",
          not the direct replication of K-form: "sometype* pf /* TEMP_REF */ = &record.f; *pf = new_val"
*)
open Ast
open K_form
open C_form

let do_fold_left2 f result l1 l2 loc msg =
    let len1 = List.length l1 in
    let len2 = List.length l2 in
    (if len1 <> len2 then
        raise_compile_err loc (msg ^ (sprintf " len1=%d, len2=%d" len1 len2)) else ();
    List.fold_left2 f result l1 l2)

(* Finds a set of immutable values that can potentially be replaced
   with the expressions that they are initalized with, e.g.

   val b = a + 1; foo(b)
   can be replaced with foo(a+1).

   Here we find a superset of such values, i.e. a set of values
   that are pure expressions and used just once.
   If a value is used more than once, it makes
   sense to store it in a temporary variable.

   Later on we shrink this superset. We check that their initialization
   expressions can be represented as scalar C expressions.
   This is a recursive rule that cannot be checked at this stage.
*)
let find_single_use_vals topcode =
    (let count_map = ref (Env.empty: int Env.t) in
    let decl_const_vals = ref (IdSet.empty) in
    let rec count_atom a loc callb =
        match a with
        | Atom.Id i ->
            if IdSet.mem i !decl_const_vals then
                let n = match (Env.find_opt i !count_map) with
                    | Some(n) -> n
                    | _ -> 0
                in count_map := Env.add i (n+1) !count_map
            else ()
        | _ -> ()
    and count_ktyp t loc callb = ()
    and count_kexp e callb =
        (* we put to decl_const_vals only the values declared with
           "val" operator, which means they are declared by
           user or are temporary intermediate values.
           we do not put there function parameters and
           loop counters, because they cannot be replaced with
           any expressions. They themselves are expressions.
        *)
        match e with
        | KDefVal(k, e1, loc) ->
            let {kv_flags} = get_kval k loc in
            (* We only replace those values with expressions which are temporary
                and computed using pure expressions *)
            let good_temp = kv_flags.val_flag_tempref || kv_flags.val_flag_temp in
            if good_temp && (K_deadcode_elim.pure_kexp e1) then
                decl_const_vals := IdSet.add k !decl_const_vals
            else ();
            count_kexp e1 callb
        | KExpCall(f, _, (_, loc)) ->
            (* count f twice to make sure it will not be included into u1vals, because if
               f is function pointer, then in C the call will be converted to
               `f.fp(args, f.fcv)`, i.e. f is used twice here, so we need to save it anyway *)
            count_atom (Atom.Id f) loc callb;
            fold_kexp e callb
        | _ -> fold_kexp e callb
    in let count_callb =
    {
        kcb_fold_ktyp=Some(count_ktyp);
        kcb_fold_kexp=Some(count_kexp);
        kcb_fold_atom=Some(count_atom);
        kcb_fold_result=0
    } in
    List.iter (fun e -> count_kexp e count_callb) topcode;
    IdSet.filter (fun i -> match (Env.find_opt i !count_map) with Some 1 -> true | _ -> false) !decl_const_vals)

let occurs_id_kexp i0 e =
    let r_occurs = ref false in
    let rec occurs_atom a loc callb =
        match a with
        | Atom.Id i ->
            if i = i0 then r_occurs := true else ()
        | _ -> ()
    and occurs_ktyp t loc callb = ()
    and occurs_kexp e callb = if !r_occurs then () else fold_kexp e callb
    in let occurs_callb =
    {
        kcb_fold_ktyp=Some(occurs_ktyp);
        kcb_fold_kexp=Some(occurs_kexp);
        kcb_fold_atom=Some(occurs_atom);
        kcb_fold_result=0
    } in
    let loc = get_kexp_loc e in
    (* occurs_id_kexp main use is to find some loop or other complex expression invariants.
       if "i0" is temp ref, i.e. a pointer to some part of a complex data type,
       its contents can be implictly modified via a variable/value with different name.
       so we always return true, i.e. "i0" cannot be considered a constant w.r.t "e" *)
    let f = match (kinfo_ i0 loc) with
        | KVal {kv_flags} -> kv_flags.val_flag_tempref
        | _ -> false
        in
    f || (occurs_kexp e occurs_callb; !r_occurs)

type block_kind_t =
    | BlockKind_Global
    | BlockKind_Fun of id_t
    | BlockKind_Branch
    | BlockKind_Try
    | BlockKind_Loop
    | BlockKind_LoopND
    | BlockKind_Case

type block_ctx_t =
{
    bctx_kind: block_kind_t;
    bctx_label: id_t;
    bctx_br_label: id_t;
    bctx_for_flags: for_flags_t;
    mutable bctx_status: cexp_t;
    mutable bctx_par_status: cexp_t;
    mutable bctx_prologue: cstmt_t list;
    mutable bctx_cleanup: cstmt_t list;
    mutable bctx_break_used: int;
    mutable bctx_continue_used: int;
    mutable bctx_label_used: int;
}

let gen_ccode_prologue ismain loc =
    CExp(CExpCCode(
        ("// this is autogenerated file, do not edit it.\n" ^
        "#include \"ficus/ficus.h\"\n" ^
        (if ismain then "#include \"ficus/impl/ficus.impl.h\"\n" else "")
        ), loc)) ::
    []

let gen_main ismain mod_names loc =
    if not ismain then [] else
        let (_, fwd_decls, init_calls, deinit_calls) = List.fold_left
            (fun (idx, fwd_decls, init_calls, deinit_calls) m ->
                (idx+1,
                (if idx = 0 then fwd_decls else
                (sprintf "FX_EXTERN_C int fx_init_%s();\nFX_EXTERN_C void fx_deinit_%s();\n" m m) :: fwd_decls),
                ((sprintf "   if (fx_status >= 0) fx_status = fx_init_%s();\n" m) :: init_calls),
                ((sprintf "   fx_deinit_%s();\n" m) :: deinit_calls))) (0, [], [], []) mod_names
            in
        [CExp(CExpCCode((
        (String.concat "" fwd_decls) ^
        "\nint main(int argc, char** argv)\n{\n" ^
        "   fx_init(argc, argv);\n" ^
        "   int fx_status = FX_OK;\n" ^
        (String.concat "" init_calls) ^
        (String.concat "" (List.rev deinit_calls)) ^
        "   return fx_deinit(fx_status);\n" ^
        "}"), loc))]

let gen_ccode cmods kmod c_fdecls mod_init_calls =
    (*let user_exceptions_ofs = ref 0 in
    let top_exn_vals = ref ([]: (id_t*cexp_t) list) in*)
    let {km_name; km_cname; km_top; km_main} = kmod in
    let mod_sc = [ScModule km_name] in
    let top_code = km_top in
    let top_inline_ccode = ref ([]: cstmt_t list) in
    let fwd_fdecls = ref ([]: cstmt_t list) in
    let module_cleanup = ref ([]: cstmt_t list) in
    let defined_syms = ref (IdSet.empty) in
    let i2e = ref (Env.empty: cexp_t Env.t) in
    let u1vals = find_single_use_vals top_code in
    let block_stack = ref ([]: block_ctx_t list) in
    let for_letters = ["i"; "j"; "k"; "l"; "m"] in
    let fx_status = get_id "fx_status" in

    let make_fx_status loc = make_id_t_exp fx_status CTypCInt loc in

    let add_to_defined f =
        defined_syms := IdSet.add f !defined_syms
    in
    let ensure_sym_is_defined_or_declared f loc =
        if (IdSet.mem f !defined_syms) then () else
            (add_to_defined f;
            fwd_fdecls := CDefForwardSym (f, loc) :: !fwd_fdecls)
    in

    let check_inside_loop is_break loc =
        let rec check_inside_loop_ s =
            match s with
            | top :: rest ->
                let {bctx_kind; bctx_for_flags} = top in
                (match bctx_kind with
                | BlockKind_Loop | BlockKind_LoopND ->
                    if bctx_for_flags.for_flag_nested then
                        check_inside_loop_ rest
                    else
                        if is_break then
                            top.bctx_break_used <- top.bctx_break_used + 1
                        else
                            top.bctx_continue_used <- top.bctx_continue_used + 1
                | BlockKind_Fun _ | BlockKind_Global ->
                    raise_compile_err loc
                        (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
                | _ -> check_inside_loop_ rest)
            | _ ->
                raise_compile_err loc
                    (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
        in check_inside_loop_ !block_stack
    in

    let curr_block_ctx loc = match !block_stack with
        | top :: _ -> top
        | _ -> raise_compile_err loc "cgen: empty block stack!"
    in

    let curr_func loc =
        match (List.find_opt (fun bctx ->
                match bctx.bctx_kind with
                | BlockKind_Fun _ -> true
                | _ -> false) !block_stack)
        with
        | Some({bctx_kind=BlockKind_Fun f}) -> f
        | _ -> noid
    in

    let new_block_ctx_ kind for_flags loc =
        let l_basename = match kind with
            | BlockKind_Global | BlockKind_Fun _ -> "cleanup"
            | _ -> "catch" in
        let l = make_label l_basename (get_end_loc loc) in
        let br_l = if kind <> BlockKind_LoopND then noid else
            make_label "break" (get_end_loc loc) in
        let bctx = {bctx_kind = kind; bctx_label=l;
                    bctx_br_label = br_l;
                    bctx_for_flags = for_flags;
                    bctx_status = make_dummy_exp loc;
                    bctx_par_status = make_dummy_exp loc;
                    bctx_prologue=[]; bctx_cleanup=[];
                    bctx_break_used=0; bctx_continue_used=0;
                    bctx_label_used=0} in
        block_stack := bctx :: !block_stack
    in

    let new_block_ctx kind loc = new_block_ctx_ kind (default_for_flags()) loc
    in

    let new_for_block_ctx ndims for_flags status par_status loc =
        let kind = if ndims = 1 then BlockKind_Loop else BlockKind_LoopND in
        let _ = new_block_ctx_ kind for_flags loc in
        let bctx = curr_block_ctx loc in
        bctx.bctx_status <- status;
        bctx.bctx_par_status <- par_status
    in

    let pop_block_ctx loc =
        match !block_stack with
        | _ :: rest -> block_stack := rest
        | _ -> raise_compile_err loc "cgen: empty block stack!"
    in

    let curr_block_label loc =
        let bctx = curr_block_ctx loc in
        bctx.bctx_label_used <- bctx.bctx_label_used + 1;
        make_id_exp bctx.bctx_label loc
    in

    let parent_block_label loc = match !block_stack with
        | _ :: parent :: _ ->
            parent.bctx_label_used <- parent.bctx_label_used + 1;
            make_id_exp parent.bctx_label loc
        | _ ->
            raise_compile_err loc "cgen internal err: there is no parent block!"
    in

    let add_fx_call_ call_exp ccode lbl loc =
        let fx_call_e = make_call !std_FX_CALL (call_exp :: lbl :: []) CTypVoid loc in
        (CExp fx_call_e) :: ccode
    in

    let add_fx_call call_exp ccode loc =
        add_fx_call_ call_exp ccode (curr_block_label loc) loc
    in

    let add_local i ctyp flags e0_opt ccode loc =
        let {ctp_ptr; ctp_free=(freem, freef)} = C_gen_types.get_ctprops ctyp loc in
        let need_dtor = freem <> noid || freef <> noid in
        if need_dtor then
            (let bctx = curr_block_ctx loc in
            let init_exp = if ctp_ptr then (make_nullptr loc) else CExpInit([], (ctyp, loc)) in
            let (i_exp, prologue) = create_cdefval i ctyp flags "" (Some init_exp) bctx.bctx_prologue loc in
            bctx.bctx_prologue <- prologue;
            bctx.bctx_cleanup <- C_gen_types.gen_free_code i_exp ctyp true true bctx.bctx_cleanup loc;
            (i_exp, (match (e0_opt, ctp_ptr) with
            | (Some(CExpLit(LitNil, _)), true) -> ccode
            | (Some(e0), _) -> C_gen_types.gen_copy_code e0 i_exp ctyp ccode loc
            | _ -> ccode)))
        else
            create_cdefval i ctyp flags "" e0_opt ccode loc
    in

    let add_local_tempref i ctyp flags e0 ccode loc =
        let {ctp_ptr} = C_gen_types.get_ctprops ctyp loc in
        let (e, ctyp) =
            if ctp_ptr && not flags.val_flag_mutable then
                (e0, ctyp)
            else
                let ctyp_ptr = make_ptr ctyp in
                let deref_i_exp = CExpUnOp(COpDeref, (make_id_t_exp i ctyp_ptr loc), (ctyp, loc)) in
                let _ = i2e := Env.add i deref_i_exp !i2e in
                ((cexp_get_addr e0), ctyp_ptr)
            in
        create_cdefval i ctyp flags "" (Some e) ccode loc
    in

    let get_dstexp dstexp_r prefix ctyp ccode loc =
        match (ctyp, !dstexp_r) with
        | (CTypVoid, _) -> ((make_dummy_exp loc), ccode)
        | (_, Some(dst_exp)) -> (dst_exp, ccode)
        | _ ->
            let i = gen_temp_idc prefix in
            let (i_exp, ccode) = add_local i ctyp (default_tempval_flags()) None ccode loc in
            dstexp_r := (Some i_exp);
            (i_exp, ccode)
    in

    let get_struct cexp =
        let (ctyp, cloc) = get_cexp_ctx cexp in
        let rec try_deref cexp ctyp =
            match ctyp with
            | CTypRawPtr(_, ctyp1) -> try_deref (cexp_deref cexp) ctyp1
            | _ ->
                (match ctyp with
                | CTypName tn ->
                    (match (cinfo_ tn cloc) with
                    | CTyp {contents={ct_typ=CTypStruct(_, relems); ct_data_start}} ->
                        (tn, cexp, relems, ct_data_start)
                    | CTyp {contents={ct_typ=CTypRawPtr(_, CTypStruct(rn, relems)); ct_data_start}} ->
                        ((Utils.opt_get rn noid), (cexp_deref cexp), relems, ct_data_start)
                    | _ -> raise_compile_err cloc
                        (sprintf "the type '%s' is not a structure" (get_idc_cname tn cloc)))
                | CTypStruct(rn, relems) -> ((Utils.opt_get rn noid), cexp, relems, 0)
                | _ -> raise_compile_err cloc "a structure is expected here")
        in try_deref cexp ctyp
    in

    let unpack_fun_args args rt is_nothrow =
        (* exclude "fx_fv" from real args if any *)
        let (real_args, have_fv_arg) = match (List.rev args) with
            | (_, _, flags) :: rest when (List.mem CArgFV flags) -> (rest, true)
            | rargs -> (rargs, false)
            in
        (* extract and exclude fx_result, if any *)
        let (real_args, ret_id, ret_rt) = match real_args with
            | (i, t, flags) :: rest when (List.mem CArgRetVal flags) -> (rest, i, t)
            | _ -> (real_args, noid, if is_nothrow then rt else CTypVoid)
        in
        let real_args = List.rev real_args in
        (real_args, ret_id, ret_rt, have_fv_arg)
    in

    let make_break_stmt loc =
        (check_inside_loop true loc;
        CExp (make_call !std_FX_BREAK [curr_block_label loc] CTypVoid loc))
    in

    let make_continue_stmt loc =
        (check_inside_loop false loc;
        CExp (make_call !std_FX_CONTINUE [curr_block_label loc] CTypVoid loc))
    in

    let handle_temp_ref flags e ctyp =
        if flags.val_flag_tempref then
            (true, (cexp_get_addr e), CTypRawPtr([], ctyp))
        else
            (false, e, ctyp)
    in

    let id2cexp i save ccode loc =
        match (Env.find_opt i !i2e) with
        | Some(e) ->
            (match (save, e) with
            | (false, _) | (_, CExpIdent _) | (_, CExpLit _)
            | (_, CExpUnOp(COpDeref, (CExpIdent _), _))
                -> (e, ccode)
            | _ ->
                let (ctyp, eloc) = get_cexp_ctx e in
                let {kv_flags} = get_kval i loc in
                let i2 = dup_idc i in
                let (add_deref, e, ctyp) = handle_temp_ref kv_flags e ctyp in
                let (i2_exp, ccode) = add_local i2 ctyp kv_flags (Some e) ccode loc in
                i2e := Env.add i i2_exp !i2e;
                ((if add_deref then (cexp_deref i2_exp) else i2_exp), ccode))
        | _ ->
            let e = make_id_exp i loc in
            let e = (match cinfo_ i loc with
            | CVal {cv_typ; cv_flags} ->
                if (is_val_global cv_flags) || (get_val_ctor cv_flags) <> noid then
                    ensure_sym_is_defined_or_declared i loc
                else ();
                (match cv_typ with
                | CTypRawPtr(_, ctyp2) when ctyp2 = cv_typ -> cexp_deref e
                | _ -> e)
            | _ -> e)
            in (e, ccode)
    in

    let is_immutable_atomic_cexp e =
        match e with
        | CExpLit _ -> true
        | CExpIdent(i, (t, loc)) ->
            let {ctp_scalar} = C_gen_types.get_ctprops t loc in
            ctp_scalar && (match (cinfo_ i loc) with
                | CVal {cv_flags} -> not (cv_flags.val_flag_mutable)
                | _ -> false)
        | _ -> false
        in

    let finalize_loop_body body_code enable_break_continue loc =
        let end_loc = get_end_loc loc in
        let bctx = curr_block_ctx loc in
        let {bctx_kind; bctx_prologue; bctx_cleanup; bctx_status; bctx_par_status;
            bctx_break_used; bctx_continue_used; bctx_for_flags;
            bctx_label; bctx_br_label; bctx_label_used} = bctx in
        let _ = if bctx_kind = BlockKind_Loop || bctx_kind = BlockKind_LoopND then
            () else raise_compile_err loc "cgen: the current context is not a loop" in
        let epilogue = List.rev bctx_cleanup in
        let is_parallel = bctx_for_flags.for_flag_parallel in
        let (br_label, epilogue) =
            if bctx_label_used + bctx_break_used + bctx_continue_used = 0 then
                (noid, epilogue)
            else
                let parent_label_exp = parent_block_label end_loc in
                let epilogue = epilogue @ [CStmtLabel(bctx_label, end_loc)] in
                let _ = if enable_break_continue || bctx_continue_used + bctx_break_used = 0 then [] else
                    raise_compile_err loc "cgen: cannot use break/continue inside comprehensions" in
                let continue_code = if bctx_continue_used = 0 then []
                    else if not is_parallel then
                        [CExp (make_call !std_FX_CHECK_CONTINUE [] CTypVoid end_loc)]
                    else
                        raise_compile_err loc "cgen: 'continue' may not be used inside parallel for"
                    in
                let (br_label, break_code) = if bctx_break_used = 0 then (noid, []) else
                    if bctx_br_label = noid then
                        (noid, [CExp (make_call !std_FX_CHECK_BREAK [] CTypVoid end_loc)])
                    else if not is_parallel then
                        let br_label_exp = make_id_exp bctx_br_label end_loc in
                        (bctx_br_label, [CExp (make_call !std_FX_CHECK_BREAK_ND [br_label_exp] CTypVoid end_loc)])
                    else
                        raise_compile_err loc "cgen: 'break' may not be used inside parallel for"
                    in
                let check_exn_code = if not is_parallel then
                        [CExp (make_call !std_FX_CHECK_EXN [parent_label_exp] CTypVoid end_loc)]
                    else
                        [CExp (make_call (get_id "FX_CHECK_EXN_PARALLEL") [bctx_status; bctx_par_status] CTypVoid end_loc)]
                    in
                (br_label, (check_exn_code @ break_code @ continue_code @ epilogue))
            in
        let body_code = epilogue @ body_code @ bctx_prologue in
        let body_stmt = rccode2stmt body_code loc in
        pop_block_ctx end_loc; (br_label, body_stmt)
    in

    let atom2cexp_ a save ccode loc =
        match a with
        | Atom.Lit(l) ->
            (match l with
            | LitString _ ->
                (* since FX_MAKE_STR(<string_literal>) creates a string with NULL reference counter and
                without allocating string in memory heap, there is no need to call destructor for it *)
                let e0 = make_call !std_FX_MAKE_STR ((make_lit_exp l loc) :: []) CTypString loc in
                create_cdefval (gen_temp_idc "slit") CTypString (default_val_flags()) "" (Some e0) ccode loc
            | _ ->
                let e = make_lit_exp l loc in (e, ccode))
        | Atom.Id(i) -> id2cexp i save ccode loc
    in

    let atom2cexp a ccode loc = atom2cexp_ a false ccode loc
    in

    let fix_nil e ktyp =
        match e with
        | CExpInit([], _) ->
            let loc = get_cexp_loc e in
            let {ktp_scalar; ktp_ptr} = K_annotate_types.get_ktprops ktyp loc in
            if not (ktp_scalar || ktp_ptr) then e else (make_int_exp 0 loc)
        | _ -> e
    in

    let decl_plain_arr arr_id elem_ctyp arr_data ccode loc =
        match arr_data with
        | [] -> ((make_nullptr loc), ccode)
        | _ ->
            let arr_ctyp = CTypRawArray ([CTypConst], elem_ctyp) in
            let arr_data_exp = CExpInit(arr_data, (arr_ctyp, loc)) in
            create_cdefval arr_id arr_ctyp (default_val_flags()) "" (Some arr_data_exp) ccode loc
    in

    let make_make_arr_call arr_exp shape data ccode0 lbl loc =
        let arr_ctyp = get_cexp_typ arr_exp in
        let dims = List.length shape in
        let shape_ctyp = CTypRawArray ([CTypConst], CTypInt) in
        let shape_arr = CExpInit(shape, (shape_ctyp, loc)) in
        let (shape_exp, ccode) = create_cdefval (gen_temp_idc "shape") shape_ctyp
            (default_val_flags()) "" (Some shape_arr) [] loc in
        let elem_ctyp = match arr_ctyp with
            | CTypArray(dims0, elem_ctyp) ->
                if dims0 = dims then () else
                    raise_compile_err loc (sprintf "cgen: incorrect number of shape elements (actual: %d, expected: %d)" dims dims0);
                elem_ctyp
            | _ -> raise_compile_err loc "cgen: invalid output type of array construction expression"
            in
        let (data_exp, ccode) = decl_plain_arr (gen_temp_idc "data") elem_ctyp data ccode loc in
        let sizeof_elem_exp = make_call !std_sizeof [CExpTyp(elem_ctyp, loc)] CTypSize_t loc in
        let free_f_exp = match (C_gen_types.get_free_f elem_ctyp true false loc) with
            | (_, (Some free_f)) -> CExpCast(free_f, !std_fx_free_t, loc)
            | _ -> make_nullptr loc
            in
        let copy_f_exp = match (C_gen_types.get_copy_f elem_ctyp true false loc) with
            | (_, Some(copy_f)) -> CExpCast(copy_f, !std_fx_copy_t, loc)
            | _ -> make_nullptr loc
            in
        let call_mkarr = make_call !std_fx_make_arr [(make_int_exp dims loc); shape_exp;
            sizeof_elem_exp; free_f_exp; copy_f_exp; data_exp; (cexp_get_addr arr_exp)] CTypCInt loc in
        let ccode = add_fx_call_ call_mkarr ccode lbl loc in
        (rccode2stmt ccode loc) :: ccode0
    in

    let decl_arr arr_ctyp shape data dstexp_r ccode loc =
        let (arr_exp, ccode) = get_dstexp dstexp_r "arr" arr_ctyp ccode loc in
        (arr_exp, (make_make_arr_call arr_exp shape data ccode (curr_block_label loc) loc))
    in

    let make_fun_arg e loc =
        let ctyp = get_cexp_typ e in
        let {ctp_pass_by_ref} = C_gen_types.get_ctprops ctyp loc in
        if ctp_pass_by_ref then (cexp_get_addr e) else e
    in

    let maybe_deref_fun_arg idx arg t flags loc =
        match ((List.mem CArgPassByPtr flags), t) with
        | (true, CTypRawPtr(_, t)) ->
            ((cexp_deref arg), t)
        | (true, _) ->
            raise_compile_err loc (sprintf
                "cgen: invalid type of argument #%d; it's passed by pointer, but the type is not pointer"
                idx)
        | _ -> (arg, t)
    in

    let make_cons_call hd_exp tl_exp addref_tl l_exp ccode loc =
        let ctyp = get_cexp_typ l_exp in
        let hd_exp = make_fun_arg hd_exp loc in
        let lcon = C_gen_types.get_constructor ctyp true loc in
        let call_cons = make_call lcon [hd_exp; tl_exp; make_bool_exp addref_tl loc; cexp_get_addr l_exp] CTypCInt loc in
        add_fx_call call_cons ccode loc
    in

    let make_mkref_call arg_exp r_exp ccode loc =
        let ctyp = get_cexp_typ r_exp in
        let arg_exp = make_fun_arg arg_exp loc in
        let rcon = C_gen_types.get_constructor ctyp true loc in
        let call_mkref = make_call rcon [arg_exp; cexp_get_addr r_exp] CTypCInt loc in
        add_fx_call call_mkref ccode loc
    in

    let add_size_eq_check check_list ccode lbl loc =
        match check_list with
        | e0 :: rest ->
            let check_exp = List.fold_left (fun e check_i ->
                CExpBinOp(COpLogicAnd, e, check_i, (CTypBool, loc))) e0 rest in
            let check_call = make_call !std_FX_CHECK_EQ_SIZE [check_exp; lbl] CTypVoid loc in
            (CExp check_call) :: ccode
        | _ -> ccode
    in

    let for_err_msg for_idx nfors i msg =
        let for_msg_prefix = if nfors = 1 then "" else if for_idx = 0 then "outer "
        else if for_idx = nfors-1 then "inner " else
            (sprintf "%d-%s nested " for_idx (Utils.num_suffix for_idx)) in
        let i = i+1 in
        let it_clause = if i <= 0 then "" else (sprintf ", %d-%s iteration clause" i (Utils.num_suffix i)) in
        sprintf "cgen: %sfor-loop%s: %s" for_msg_prefix it_clause msg
    in

    let compute_for_ndims for_idx nfors idoml for_loc =
        let (_, ndims) = List.fold_left (fun (k, ndims) (_, dom_i) ->
            let ndims_i =
                match dom_i with
                | Domain.Elem(Atom.Id d) ->
                    (match (get_idk_ktyp d for_loc) with
                    | KTypArray(n, _) -> n
                    | _ -> 1)
                | _ -> 1
            in
            if ndims <> 0 && ndims <> ndims_i then
                raise_compile_err for_loc (for_err_msg k for_idx nfors
                (sprintf "dimensionalities of the simultaneously iterated collections/ranges are not the same (...%d...%d...)" ndims ndims_i))
            else ();
            (k+1, ndims_i)) (0, 0) idoml
        in ndims
    in

    let process_for lbl idoml at_ids for_idx nfors ndims dims_ofs nested_e_idoml init_ccode loc =
        let for_loc = get_start_loc loc in
        let end_for_loc = get_end_loc loc in
        let _ = if idoml <> [] then () else
            raise_compile_err loc (for_err_msg for_idx nfors (-1) "empty list of for iteration values")
            in
        let (idoml, at_ids) = if at_ids = [] then (idoml, at_ids) else
            (let have_good_idx = List.exists (fun (_, dom_i) -> match dom_i with
                | Domain.Elem (Atom.Id k) | Domain.Fast (Atom.Id k) ->
                    (match (deref_ktyp (get_idk_ktyp k loc) loc) with
                    | KTypList _ -> false
                    | _ -> true)
                | Domain.Range (_, _, Atom.Lit (LitInt 1L)) -> false
                | Domain.Range (_, Atom.Lit (LitNil), _) -> false
                | _ -> true) idoml
                in
            (match (have_good_idx, at_ids) with
            | (true, _) -> (idoml, at_ids)
            | (false, i :: []) ->
                let i_iter = (i, Domain.Range(Atom.Lit(LitInt 0L), Atom.Lit LitNil, Atom.Lit(LitInt 1L))) in
                ((i_iter :: idoml), [])
            | _ -> raise_compile_err loc
                (for_err_msg for_idx nfors 0 "here @ clause should contain just one scalar index")))
            in
        let get_iter_id k at_ids prefix =
            match at_ids with
            | [] -> gen_temp_idc prefix
            | _ ->
                if k < (List.length at_ids) then
                    (List.nth at_ids k)
                else
                    raise_compile_err loc (for_err_msg for_idx nfors 0
                        "the list of '@' indices is too short for array; looks like it's bug in type checker")
            in
        (*
            Compute various elements/attributes/parts of the for loop:

            list_exps: lst0, lst1, ... - lists (if any) which are iterated.
            i_exps: i, j, k etc. - for-loop integer iteration variables (only for closed ranges and arrays, not for open ranges or lists)
            n_exps: n0, n1, n2 etc. - for-loop limits (also integers)
            for_checks0: extra checks (besides `i < n0`, `j < n1`, `k < n2` etc.). Used for iteration over list(s): lst0[!=0], lst1[!=0] etc. ...
            incr_exps0: extra increment operations (besides `i++`, `j++`, `k++`). Used for iteration over lists(s): lst0=lst0->tl, lst1=lst1->tl, ...
            init_checks: the checks that we need to put before the loop into FX_CHECK_NE_SIZE((check0 || check1 || check2 ...), catch_label) macro.
                We check that all closed ranges and all simultaneously iterated 1D or nD arrays have the same shape.
                The lists sizes are not checked because we don't know their sizes before the loop,
                    and we don't want to make extra loop to count their lengths.
            init_ccode: inital code for the loop:
                Save all the arrays, lists etc. if needed to guarantee that they are not destroyed
                    in the middle of loop (and that they are computed just once).
                Save start:stop:step expressions in the ranges.
                Compute n_i=FX_LOOP_COUNT(start_i, stop_i, step_i) for each range.
                Save n0_i,n1_i,...=arr_i.dim[0,1,...].size.
                init_ccode does not include the check for size/shape equality/inequality (see init_checks). It's added after this let statement.
            pre_body_ccode: code before the inner-most loop. Now it's used only for arrays:
                elem_type0* ptr_arr0 = FX_PTR_<ndims>D(arr_0, i, j, ..., 0);
                elem_type1* ptr_arr1 = FX_PTR_<ndims>D(arr_1, i, j, ..., 0);
                that is, get the pointers to the linear slices of the iterated arrays.
                [TODO] we can check whether all the iterated arrays are continuous and modify n_exps accordingly,
                    e.g. in 2D case with 2 arrays A and B:
                    if(FX_ARR_CONTINUOUS(A) && FX_ARR_CONTINUOUS(B)) {
                        n1 *= n0;
                        n0 = 1;
                    }
                    with such a trick, the arrays are processed completely with a single run of inner loop with minimal overhead.
                note that in the case of 1D array processing pre_body_ccode immediately follows init_ccode and init_checks.
            body_pairs: a list of pairs (v_0, exp_0), (v_1, exp_1), ...
                This is a list of values that need to be extracted in the beginning of loop body.
                We keep them separately without forming expressions v_0 = exp_0, because in the case of complex types, e.g. strings or nested arrays,
                we need to initalize v_i separately and put the destructors to the for-loop body cleanup section. All this is done using add_local,
                but for that we need to form a nested for-loop body context, which we form after this let.
            post_checks: the checks that we need to put after the loop into FX_CHECK_NE_SIZE((check0 || check1 || check2 ...), catch_label) macro.
                We check that all closed ranges/arrays and all simultaneously iterated lists finished at once.
                In this let statement we put only lists. The range check is added later if needed.
                a) just list case:
                fx_list0_t lst0 = list0;
                fx_list1_t lst1 = list1;
                for(; lst0 && lst1; lst0=lst0->tl, lst1=lst1->tl) {
                    int a=lst0->hd, b=lst1->hd;
                    s += abs(a-b);
                }
                FX_CHECK_NE_SIZE(lst0 || lst1, catch_label); // check that both lists finished simultaneously.
                b) list and "closed range"/array case:
                fx_list0_t lst0 = list0;
                fx_list1_t lst1 = list1;
                for(int i = 0; i < n && lst0 && lst1; lst0=lst0->tl, lst1=lst1->tl) {
                    int a=lst0->hd, b=lst1->hd;
                    if(a!=b) {printf("diff=%d at %d\n", abs(a-b), i);}
                }
                FX_CHECK_NE_SIZE(i < n || lst0 || lst1, catch_label); // check that both lists and the range finished simultaneously.
        *)
        let (_, list_exps, i_exps, n_exps, for_checks0, incr_exps0, init_checks,
            init_ccode, pre_body_ccode, body_elems, post_checks) = List.fold_left
            (fun (k, list_exps, i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                pre_body_ccode, body_elems, post_checks) (iter_val_i, dom_i) ->
                let (lists_i, i_exps, n_exps, for_checks, incr_exps, init_checks,
                    init_ccode, pre_body_ccode, body_elems, post_checks) = match dom_i with
                    | Domain.Range(a, b, delta) ->
                        let (aug_add_delta, add_delta, d_exp, init_ccode) = match delta with
                            | Atom.Lit(LitInt 0L) ->
                                raise_compile_err for_loc (for_err_msg for_idx nfors k "the iteration step is zero")
                            | Atom.Lit (LitInt i) ->
                                let (aug_add_delta, add_delta, i) = if i > 0L then
                                        (COpAugAdd, COpAdd, i)
                                    else
                                        (COpAugSub, COpSub, (Int64.neg i))
                                    in
                                (aug_add_delta, add_delta, (make_int__exp i for_loc), init_ccode)
                            | _ ->
                                let (d_exp, init_ccode) = atom2cexp_ delta true init_ccode for_loc in
                                let init_ccode = (CExp (make_call !std_FX_CHECK_ZERO_STEP [d_exp; lbl] CTypVoid for_loc)) :: init_ccode in
                                (COpAugAdd, COpAdd, d_exp, init_ccode)
                            in
                        (match b with
                        | Atom.Lit LitNil ->
                            (*
                                int iter_var = a;
                                for(;;iter_var += delta) {
                                    ...
                                }
                            *)
                            let (a_exp, init_ccode) = atom2cexp_ a false init_ccode for_loc in
                            let (i_exp, init_ccode) = create_cdefval iter_val_i CTypInt
                                (default_val_flags()) "" (Some a_exp) init_ccode for_loc in
                            let incr_i_exp = CExpBinOp(aug_add_delta, i_exp, d_exp, (CTypVoid, for_loc)) in
                            ([], i_exps, n_exps, for_checks, incr_i_exp :: incr_exps, init_checks,
                            init_ccode, pre_body_ccode, body_elems, post_checks)
                        | _ ->
                            (*
                                // save the loop counter
                                int n = FX_LOOP_COUNT(a, b, delta); // n === loop_counter
                                // or check it
                                FX_CHECK_NE_SIZE(FX_LOOP_COUNT(a, b, delta) != loop_counter, catch_label);
                                for(int i = 0; i < loop_counter; i++) {
                                    int iter_var = a + i*delta; // compute the current value
                                }
                            *)
                            let (a_exp, init_ccode) = atom2cexp_ a true init_ccode for_loc in
                            let (b_exp, init_ccode) = atom2cexp_ b true init_ccode for_loc in
                            let is_canonical_for = match (a, delta) with
                                | ((Atom.Lit (LitInt 0L)), (Atom.Lit (LitInt 1L))) -> true
                                | _ -> false
                                in
                            let calc_n_exp = if is_canonical_for then b_exp else
                                make_call !std_FX_LOOP_COUNT [a_exp; b_exp; d_exp] CTypInt for_loc
                                in
                            let (add_elem, i_exp, i_exps, n_exps, init_checks, init_ccode) = match (i_exps, n_exps) with
                                | (prev_i :: _, prev_n :: _) ->
                                    (true, prev_i, i_exps, n_exps,
                                    (CExpBinOp(COpCompareEQ, prev_n, calc_n_exp, (CTypBool, for_loc))) :: init_checks,
                                    init_ccode)
                                | _ ->
                                    let (add_pair, i_id) = match (a, delta) with
                                        | ((Atom.Lit (LitInt 0L)), (Atom.Lit (LitInt 1L))) -> (false, iter_val_i)
                                        | _ -> (true, get_iter_id 0 at_ids (pp_id2str iter_val_i))
                                        in
                                    let (n_exp, init_ccode) =
                                        if is_canonical_for && (is_immutable_atomic_cexp b_exp) then
                                            (b_exp, init_ccode)
                                        else
                                            add_local (gen_temp_idc "n") CTypInt (default_tempval_flags())
                                                (Some calc_n_exp) init_ccode for_loc
                                        in
                                    let (i_exp, _) = add_local i_id CTypInt
                                            (default_tempvaR_flags()) None [] for_loc in
                                    (add_pair, i_exp, i_exp :: i_exps, n_exp :: n_exps, init_checks, init_ccode)
                                in
                            let body_elems = if not add_elem then body_elems else
                                let calc_i_exp = CExpBinOp(add_delta, a_exp,
                                    CExpBinOp(COpMul, i_exp, d_exp, (CTypInt, for_loc)), (CTypInt, for_loc)) in
                                (iter_val_i, calc_i_exp, (default_var_flags())) :: body_elems
                                in
                            ([], i_exps, n_exps, for_checks, incr_exps, init_checks,
                            init_ccode, pre_body_ccode, body_elems, post_checks))
                    | Domain.Elem(a) ->
                        let col_ = match a with Atom.Id i -> i | _ -> noid in
                        let ktyp = get_atom_ktyp a for_loc in
                        let ctyp = C_gen_types.ktyp2ctyp ktyp for_loc in
                        (* before running iteration over a collection,
                            we need to make sure that it will not be deallocated in the middle *)
                        let (col_exp, init_ccode) = if col_ <> noid &&
                            List.exists (fun (e, _, _) -> occurs_id_kexp col_ e) nested_e_idoml then
                                let (src_exp, init_ccode) = atom2cexp (Atom.Id col_) init_ccode for_loc in
                                (*let src_exp = make_id_exp col_ (get_idk_loc col_ for_loc) in*)
                                let (col_exp, init_ccode) = get_dstexp (ref None) (pp_id2str col_) ctyp init_ccode for_loc in
                                let init_ccode = C_gen_types.gen_copy_code src_exp col_exp ctyp init_ccode for_loc in
                                (col_exp, init_ccode)
                            else
                                atom2cexp_ a true init_ccode for_loc
                            in
                        (match (deref_ktyp ktyp for_loc) with
                        | KTypList et ->
                            (*
                                some_lst_t lst = col;
                                for(; lst [&& ...]; lst=lst->tl) {
                                    some_lst_elem_t x = lst->hd;
                                    ...
                                }
                                // optional check
                                FX_CHECK_NE_SIZE(!lst || ..., catch_label);
                            *)
                            let (l_exp, init_ccode) = create_cdefval (gen_temp_idc "lst") ctyp
                                (default_var_flags()) "" (Some col_exp) init_ccode for_loc in
                            let not_l_exp = CExpUnOp(COpLogicNot, l_exp, (CTypBool, end_for_loc)) in
                            let l_next_exp = make_assign l_exp (cexp_arrow l_exp (get_id "tl") ctyp) in
                            let c_et = C_gen_types.ktyp2ctyp et for_loc in
                            let get_hd_exp = cexp_arrow l_exp (get_id "hd") c_et in
                            let hd_flags = if (is_ktyp_scalar et) then default_tempvaR_flags() else default_tempref_flags() in
                            ([l_exp], i_exps, n_exps, (l_exp :: for_checks), (l_next_exp :: incr_exps), init_checks, init_ccode,
                            pre_body_ccode, ((iter_val_i, get_hd_exp, hd_flags) :: body_elems), not_l_exp :: post_checks)
                        | KTypString ->
                            (*
                                // either save the length
                                int_ len = str->length; // loop_counter === len
                                // or check it
                                FX_CHECK_NE_SIZE(str->length != loop_counter, catch_label);
                                for(int i = 0; i < loop_counter; i++) {
                                    char_ x = str->data[i];
                                    ...
                                }
                            *)
                            let calc_n_exp = make_call !std_FX_STR_LENGTH [col_exp] CTypInt for_loc in
                            let (i_exp, i_exps, n_exps, init_checks, init_ccode) = match (i_exps, n_exps) with
                                | (prev_i :: _, prev_n :: _) ->
                                    (prev_i, i_exps, n_exps,
                                    (CExpBinOp(COpCompareEQ, prev_n, calc_n_exp, (CTypBool, for_loc))) :: init_checks,
                                    init_ccode)
                                | _ ->
                                    let (n_exp, init_ccode) = add_local (gen_temp_idc "len") CTypInt
                                        (default_val_flags()) (Some calc_n_exp) init_ccode for_loc in
                                    let i_id = get_iter_id 0 at_ids (List.nth for_letters dims_ofs) in
                                    let (i_exp, _) = add_local i_id CTypInt
                                        (default_tempvaR_flags()) None [] for_loc in
                                    (i_exp, i_exp :: i_exps, n_exp :: n_exps, init_checks, init_ccode)
                                in
                            let get_chars = cexp_mem col_exp (get_id "data") (make_const_ptr CTypUniChar) in
                            let get_char_i = CExpBinOp(COpArrayElem, get_chars, i_exp, (CTypUniChar, for_loc)) in
                            ([], i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                            pre_body_ccode, ((iter_val_i, get_char_i, (default_var_flags())) :: body_elems), post_checks)
                        | KTypArray(ndims, et) ->
                            (*
                                // either save all the dimensions
                                int_ ni = FX_ARR_SIZE(arr, 0);
                                int_ nj = FX_ARR_SIZE(arr, 1);
                                ...
                                // or check them
                                FX_CHECK_NE_SIZE(FX_ARR_SIZE(arr, 0) != ni || FX_ARR_SIZE(arr, 1) != nj ..., catch_label);
                                for(int i = 0; i < ni; i++) {
                                    // before the inner-most loop
                                    arr_elem_t* ptr
                                    for(int j = 0; j < nj; j++) {
                                    char_ x = str->data[i];
                                    ...
                                }
                            *)
                            let (i_exps, n_exps, init_checks, init_ccode) = if n_exps = [] then
                                    let (i_exps, n_exps, init_ccode) = List.fold_left (fun (i_exps, n_exps, init_ccode) k ->
                                        let calc_n_exp = make_call !std_FX_ARR_SIZE [col_exp; (make_int_exp k for_loc)] CTypInt for_loc in
                                        let iter_letter = List.nth for_letters (k + dims_ofs) in
                                        let (n_exp, init_ccode) = add_local (gen_temp_idc ("n" ^ iter_letter)) CTypInt
                                            (default_val_flags()) (Some calc_n_exp) init_ccode for_loc in
                                        let i_id = get_iter_id k at_ids iter_letter in
                                        let (i_exp, _) = add_local i_id CTypInt (default_tempvaR_flags()) None [] for_loc in
                                        (i_exp :: i_exps, n_exp :: n_exps, init_ccode))
                                        ([], [], init_ccode) (List.init ndims (fun k -> k))
                                    in ((List.rev i_exps), (List.rev n_exps), init_checks, init_ccode)
                                else
                                    let (_, init_checks) = List.fold_left (fun (k, init_checks) prev_nk ->
                                        let calc_n_exp = make_call !std_FX_ARR_SIZE [col_exp; (make_int_exp k for_loc)] CTypInt for_loc in
                                        let init_check_k = CExpBinOp(COpCompareEQ, prev_nk, calc_n_exp, (CTypBool, for_loc)) in
                                        (k+1, init_check_k :: init_checks)) (0, init_checks) n_exps
                                    in (i_exps, n_exps, init_checks, init_ccode)
                                in
                            let c_et = C_gen_types.ktyp2ctyp et for_loc in
                            let c_et_ptr = make_ptr c_et in
                            let rev_i_exps = List.rev i_exps in
                            let inner_idx = List.hd rev_i_exps in
                            let slice_idxs = List.rev ((make_int_exp 0 for_loc) :: (List.tl rev_i_exps)) in
                            let get_arr_slice = make_call (List.nth (!std_FX_PTR_xD) (ndims-1))
                                (CExpTyp (c_et, for_loc) :: col_exp :: slice_idxs) c_et_ptr for_loc in
                            let ptr_id = gen_temp_idc ("ptr_" ^ (pp_id2str col_)) in
                            let (ptr_exp, pre_body_ccode) = create_cdefval ptr_id c_et_ptr (default_val_flags())
                                "" (Some get_arr_slice) pre_body_ccode for_loc in
                            let get_arr_elem = CExpBinOp(COpArrayElem, ptr_exp, inner_idx, (c_et, for_loc)) in
                            ([], i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                            pre_body_ccode, ((iter_val_i, get_arr_elem, default_tempvaR_flags()) :: body_elems), post_checks)
                        | _ -> raise_compile_err for_loc (for_err_msg for_idx nfors k
                            (sprintf "cannot iterate over '%s'; it needs to be array, list or string" (atom2str a)))
                        )
                    | _ ->
                        raise_compile_err for_loc (for_err_msg for_idx nfors k "unsupported type of the for loop iteration domain")
                in (k+1, lists_i @ list_exps, i_exps, n_exps, for_checks, incr_exps, init_checks,
                    init_ccode, pre_body_ccode, body_elems, post_checks))
                (0, [], [], [], [], [], [], init_ccode, [], [], []) idoml
            in
        (* add initial size checks *)
        let init_ccode = add_size_eq_check (List.rev init_checks) init_ccode lbl for_loc in
        (* in the case of 1D arrays put pre_body_ccode immediately after initialization code *)
        let (init_ccode, pre_body_ccode) = if ndims > 1 then (init_ccode, pre_body_ccode)
            else (pre_body_ccode @ init_ccode, []) in
        (* add "post" checks, if needed *)
        let post_checks = List.rev post_checks in
        let post_checks = if post_checks <> [] && i_exps <> [] then
                (CExpBinOp(COpCompareEQ, (List.hd i_exps), (List.hd n_exps), (CTypBool, end_for_loc))) :: post_checks
            else if (List.length post_checks) > 1 then post_checks else []
            in
        let post_ccode = add_size_eq_check post_checks [] lbl end_for_loc in

        (* form for-loop headers *)
        let (k_final, for_headers) = List.fold_left2 (fun (k, for_headers) i_exp n_exp ->
            let ifor_loc = get_cexp_loc n_exp in
            let init_exps = [make_assign i_exp (make_int_exp 0 ifor_loc)] in
            let check_exp = CExpBinOp(COpCompareLT, i_exp, n_exp, (CTypBool, ifor_loc)) in
            let incr_exps = [CExpUnOp(COpSuffixInc, i_exp, (CTypInt, ifor_loc))] in
            let (check_exp, incr_exps) = if k > 0 then (check_exp, incr_exps) else
                let check_exp = List.fold_left (fun check_exp e ->
                    CExpBinOp(COpLogicAnd, check_exp, e, (CTypBool, ifor_loc)))
                    check_exp (List.rev for_checks0) in
                (check_exp, incr_exps @ (List.rev incr_exps0))
                in
            (k+1, (((Some CTypInt), init_exps, (Some check_exp), incr_exps) :: for_headers))) (0, []) i_exps n_exps
            in
        (* if we have open loop or loop over lists (i.e. i_exps and n_exps are empty lists),
           we still need to form the for-loop statement *)
        let for_headers = if k_final > 0 then for_headers else
            let check_exp_opt = List.fold_left (fun check_exp_opt check_i ->
                Some (match check_exp_opt with
                | Some e -> CExpBinOp(COpLogicAnd, e, check_i, (CTypBool, for_loc))
                | _ -> check_i)) None (List.rev for_checks0) in
            [(None, [], check_exp_opt, incr_exps0)]
            in
        ((List.rev for_headers), list_exps, i_exps, n_exps, init_ccode, pre_body_ccode, body_elems, post_ccode)
    in

    let decl_for_body_elems body_elems body_ccode =
        List.fold_left (fun body_ccode (v, e, flags) ->
            let (ctyp, loc) = get_cexp_ctx e in
            let (_, body_ccode) =
                if flags.val_flag_tempref then
                    add_local_tempref v ctyp flags e body_ccode loc
                else
                    add_local v ctyp flags (Some e) body_ccode loc
                in
            body_ccode) body_ccode body_elems
    in

    let rec process_cases cases dstexp_r ccode is_catch_case kloc =
        let end_loc = get_end_loc kloc in
        let endmatch = make_label (if is_catch_case then "endcatch" else "endmatch") end_loc in
        let (have_default, em_label_used, have_epilogues, have_complex_branches, all_cases_ccode) =
            List.fold_left
            (fun (have_default, em_label_used, have_epilogues,
                have_complex_branches, all_cases_ccode) (checks_i, action_i) ->
            let (cchecks_i, pre_cchecks_i) = List.fold_left (fun (checks_i, pre_checks_i) check_ij ->
                let (ccheck_ij, ccode_ij) = kexp2cexp check_ij (ref None) [] in
                (ccheck_ij :: checks_i, ccode_ij :: pre_checks_i)) ([], []) checks_i
                in
            let ai_loc = get_kexp_loc action_i in
            let new_have_default =
                match checks_i with
                | [] -> if have_default then raise_compile_err ai_loc
                    "cgen: more than one default action" else true
                | _ -> have_default
                in
            (* for each action we create a dedicated scope with its own cleanup section;
                this is because it can be very lengthy match expressions with
                many cases (like in compilers), so if we put all the
                non-trivial locals into the common scope, the cleanup section
                will be very inefficient *)
            let ai_end_loc = get_end_loc ai_loc in
            let (ai_ccode, em_label_used_i, have_epilogue_i) =
                match action_i with
                | KExpThrow _ ->
                    let (_, ai_ccode) = kexp2cexp action_i dstexp_r [] in
                    (ai_ccode, false, false)
                | _ ->
                    let _ = new_block_ctx BlockKind_Case ai_loc in
                    let (_, ai_ccode) = kexp2cexp action_i dstexp_r [] in
                    let bctx_i = curr_block_ctx kloc in
                    let {bctx_prologue; bctx_cleanup;
                        bctx_label; bctx_label_used} = bctx_i in
                    let prologue = bctx_prologue in
                    let epilogue = List.rev bctx_cleanup in
                    let (ai_ccode, epilogue, have_epilogue_i) =
                        if epilogue = [] && prologue = [] then
                            let _ = pop_block_ctx ai_end_loc in
                            (* recompile the action code inside the parent context.
                                that is, in the case of exception, jump to the higher-level label
                                instead of this one. that probably makes compile the graph somewhat
                                simpler to analyze.
                                [TODO]
                                instead of complete re-compilation of the branch,
                                we could just replace all the bctx_label
                                occurences with the parent label *)
                            let (_, ai_ccode) = kexp2cexp action_i dstexp_r [] in
                            (ai_ccode, epilogue, false)
                        else
                            let epilogue =
                                if bctx_label_used = 0 then
                                    epilogue
                                else
                                    epilogue @ (CStmtLabel (bctx_label, ai_end_loc) :: [])
                                in
                            let _ = pop_block_ctx ai_end_loc in
                            (ai_ccode, epilogue, true)
                        in
                    let (em_label_used_i, epilogue) = if new_have_default then
                        (false, epilogue)
                    else
                        (true, ((CStmtGoto (endmatch, ai_end_loc)) :: epilogue))
                    in
                    let ai_ccode = epilogue @ ai_ccode @ prologue in
                    (ai_ccode, em_label_used_i, have_epilogue_i)
                in
            let complex_branch_i = match (cchecks_i, pre_cchecks_i) with
                | ([], []) -> false
                | (c::[], []::[]) -> false
                | _ -> true
                in
            let case_ccode = match (cchecks_i, pre_cchecks_i) with
                | ([], []) -> ai_ccode
                | _ ->
                    let ai_stmt = rccode2stmt ai_ccode ai_loc in
                    (* generate the nested if statement;
                    [TODO] need to replace it with one
                    `if (expi0 && expi1 && ... && expi{n-1}) { action_i }`
                    if possible (i.e. when all pre_check_ij's are empty) *)
                    do_fold_left2 (fun case_ccode check_ij pre_check_ij ->
                        let case_stmt = rccode2stmt case_ccode ai_end_loc in
                        let checkij_loc = get_cexp_loc check_ij in
                        let if_stmt = CStmtIf(check_ij, case_stmt, (CStmtNop ai_end_loc), checkij_loc) in
                        if_stmt :: pre_check_ij) (ai_stmt :: []) cchecks_i pre_cchecks_i ai_end_loc
                        "cgen: KExpMatch fold_left2"
                        in
            (new_have_default, em_label_used || em_label_used_i,
            have_epilogues || have_epilogue_i,
            have_complex_branches || complex_branch_i,
            case_ccode :: all_cases_ccode)) (false, false, false, false, []) cases
            in
        let parent_lbl = curr_block_label end_loc in
        let all_cases_ccode = if have_default then all_cases_ccode else
            let no_match_err = make_id_t_exp (get_id "FX_EXN_NoMatchError") CTypCInt end_loc in
            let throw_no_match = make_call !std_FX_FAST_THROW [no_match_err; parent_lbl] CTypVoid end_loc in
            [CExp throw_no_match] :: all_cases_ccode
            in
        let (em_label_used, ccode) =
            match (have_complex_branches, all_cases_ccode) with
            | (false, else_s :: ifs) ->
                let complex_if = List.fold_left (fun complex_if s_i ->
                    match s_i with
                    | CStmtIf(c_i, then_i, (CStmtNop _), loc_i) :: [] ->
                        let then_i =
                            match List.rev (stmt2ccode then_i) with
                            | (CStmtGoto(i, _) :: rest) when i = endmatch ->
                                rccode2stmt rest loc_i
                            | _ -> then_i
                        in CStmtIf(c_i, then_i, complex_if, loc_i)
                    | _ ->
                        raise_compile_err end_loc
                            "cgen: unexpected statement in the chained match statement")
                    (rccode2stmt else_s end_loc) ifs
                in
                (false, complex_if :: ccode)
            | _ -> (em_label_used, (List.concat all_cases_ccode) @ ccode)
            in
        let ccode = if not em_label_used then ccode
            else (CStmtLabel (endmatch, end_loc)) :: ccode in
        let ccode = if not have_epilogues then ccode else
            let check_exn = make_call !std_FX_CHECK_EXN (parent_lbl::[]) CTypVoid end_loc in
            (CExp check_exn) :: ccode
        in ccode

    (*
        cases:
           - input kexp is void:
                no expression should be stored anywhere,
                just need to update ccode and return "nop"
           - non-void expression,
                the result should be stored to some pre-defined value (dstid).
                returns this CExpIdent(dstid)
           - non-void expression (dstid=noid),
                the result should be returned as expression
                if needed, some temporary id is generated where the result is stored.
    *)
    and kexp2cexp kexp dstexp_r ccode =
        let (ktyp, kloc) = get_kexp_ctx kexp in
        let ctyp = C_gen_types.ktyp2ctyp ktyp kloc in
        let dummy_exp = make_dummy_exp kloc in
        (*let _ = (printf "processing kexp: "; K_pp.pprint_kexp_x kexp; printf "\n") in*)
        (*let _ = match kexp with
            | KDefFun {contents={kf_name}} ->
                printf "processing function '%s'\n" (idk2str kf_name kloc)
            | _ -> ()
        in*)

        (* generate exp and then optionally generate the assignment if needed *)
        let (assign, result_exp, ccode) = match kexp with
        | KExpNop _ -> (false, dummy_exp, ccode)
        | KExpBreak _ ->
            let break_stmt = make_break_stmt kloc in
            (false, dummy_exp, break_stmt :: ccode)
        | KExpContinue _ ->
            let continue_stmt = make_continue_stmt kloc in
            (false, dummy_exp, continue_stmt :: ccode)
        | KExpAtom(a, _) ->
            let (e, ccode) = atom2cexp a ccode kloc in
            let e = fix_nil e ktyp in
            (true, e, ccode)
        | KExpBinOp(bop, a1, a2, _) ->
            let (save_and_check, a1_is_int, a2_is_int) =
                match bop with
                | OpDiv | OpMod ->
                    let f1 = is_ktyp_integer (get_atom_ktyp a1 kloc) true in
                    let f2 = is_ktyp_integer (get_atom_ktyp a2 kloc) true in
                    (* if a2 is constant, k_cfold_dealias stage has already checked
                       that a2 is non-zero; we can skip non-zero check here *)
                    let f2 = f2 && (match a2 with Atom.Id _ -> true | _ -> false) in
                    ((f1 && f2), f1, f2)
                | _ -> (false, false, false)
                in
            let (ce1, ccode) = atom2cexp a1 ccode kloc in
            let (ce2, ccode) = atom2cexp_ a2 save_and_check ccode kloc in
            (match bop with
            | OpPow ->
                let (need_cast, ce1, ce2, rtyp, f) = match ctyp with
                    | CTypFloat(32) -> (false, ce1, ce2, ctyp, get_id "powf")
                    | CTypFloat(64) -> (false, ce1, ce2, ctyp, get_id "pow")
                    | _ ->
                        let ce1 = CExpCast(ce1, (CTypFloat 64), kloc) in
                        let ce2 = CExpCast(ce2, (CTypFloat 64), kloc) in
                        (true, ce1, ce2, (CTypFloat 64), get_id "pow") in
                let e = make_call f (ce1 :: ce2 :: []) rtyp kloc in
                let e = if need_cast then CExpCast(e, ctyp, kloc) else e in
                (true, e, ccode)
            | OpDiv ->
                if save_and_check then
                    let lbl = curr_block_label kloc in
                    let chk_denom = make_call (get_id "FX_CHECK_DIV_BY_ZERO") [ce2; lbl] CTypVoid kloc in
                    let div_exp = CExpBinOp(COpDiv, ce1, ce2, (ctyp, kloc)) in
                    (true, div_exp, (CExp chk_denom) :: ccode)
                else
                    (true, CExpBinOp(COpDiv, ce1, ce2, (ctyp, kloc)), ccode)
            | OpMod ->
                if save_and_check then
                    let lbl = curr_block_label kloc in
                    let chk_denom = make_call (get_id "FX_CHECK_DIV_BY_ZERO") [ce2; lbl] CTypVoid kloc in
                    let mod_exp = CExpBinOp(COpMod, ce1, ce2, (ctyp, kloc)) in
                    (true, mod_exp, (CExp chk_denom) :: ccode)
                else
                    let (need_cast, ce1, ce2, rtyp, f) = match ctyp with
                        | CTypInt | CTypFloat(32) -> (false, ce1, ce2, ctyp, get_id "fmodf")
                        | CTypFloat(64) -> (false, ce1, ce2, ctyp, get_id "fmod")
                        | _ ->
                            let ce1 = CExpCast(ce1, (CTypFloat 64), kloc) in
                            let ce2 = CExpCast(ce2, (CTypFloat 64), kloc) in
                            (true, ce1, ce2, (CTypFloat 64), get_id "fmod") in
                    let e = make_call f (ce1 :: ce2 :: []) rtyp kloc in
                    let e = if need_cast then CExpCast(e, ctyp, kloc) else e in
                    (true, e, ccode)
            | OpCons ->
                (*
                    l = e1 :: e2;
                    if !dstexp_r = None && (e2 is single-use id from u1vals) && (ce2 is id) then
                        re-use ce2 as l
                    else
                        obtain l using get_dstexp.
                *)
                let a2_id = match a2 with (Atom.Id i) when IdSet.mem i u1vals -> i | _ -> noid in
                let ce2_id = match ce2 with CExpIdent(i, _) -> i | _ -> noid in
                let (reuse_ce2, (l_exp, _)) = if (Utils.is_none !dstexp_r) && a2_id <> noid && ce2_id <> noid then
                        (true, (ce2, []))
                    else (false, (get_dstexp dstexp_r "lst" ctyp [] kloc)) in
                let ccode = make_cons_call ce1 ce2 (not reuse_ce2) l_exp ccode kloc in
                (false, l_exp, ccode)
            | _ ->
                let c_bop = (match bop with
                    | OpAdd -> COpAdd
                    | OpSub -> COpSub
                    | OpMul -> COpMul
                    | OpDiv -> COpDiv
                    | OpShiftLeft -> COpShiftLeft
                    | OpShiftRight -> COpShiftRight
                    | OpBitwiseAnd ->
                        (match ktyp with KTypBool -> COpLogicAnd | _ -> COpBitwiseAnd)
                    | OpBitwiseOr ->
                        (match ktyp with KTypBool -> COpLogicOr | _ -> COpBitwiseOr)
                    | OpBitwiseXor -> COpBitwiseXor
                    | OpCompareEQ -> COpCompareEQ
                    | OpCompareNE -> COpCompareNE
                    | OpCompareLE -> COpCompareLE
                    | OpCompareGE -> COpCompareGE
                    | OpCompareLT -> COpCompareLT
                    | OpCompareGT -> COpCompareGT
                    | OpCons | OpPow | OpMod | OpLogicAnd | OpLogicOr | OpSpaceship | OpDotSpaceship
                    | OpDotMul | OpDotDiv | OpDotMod | OpDotPow
                    | OpDotCompareEQ | OpDotCompareNE | OpDotCompareLE
                    | OpDotCompareGE | OpDotCompareLT | OpDotCompareGT ->
                        raise_compile_err kloc (sprintf "cgen: unsupported op '%s' at this stage"
                        (binop_to_string bop)))
                in (match (c_bop, (get_cexp_typ ce1)) with
                | (COpCompareEQ, CTypString) ->
                    let f_exp = get_id "fx_streq" in
                    let call_streq = make_call f_exp [(cexp_get_addr ce1); (cexp_get_addr ce2)] CTypBool kloc in
                    (true, call_streq, ccode)
                | _ -> (true, CExpBinOp(c_bop, ce1, ce2, (ctyp, kloc)), ccode)))
        | KExpUnOp(OpMkRef, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode kloc in
            let (r_exp, _) = get_dstexp dstexp_r "r" ctyp [] kloc in
            let ccode = make_mkref_call ce1 r_exp ccode kloc in
            (false, r_exp, ccode)
        | KExpUnOp(OpDeref, a1, _) ->
            let a_id = match a1 with
                | Atom.Id a_id -> a_id
                | _ -> raise_compile_err kloc "cgen: deref operand is not an identifier"
                in
            let (ce, ccode) = id2cexp a_id false ccode kloc in
            let n_id = get_id "data" in
            (true, (cexp_arrow ce n_id ctyp), ccode)
        | KExpUnOp(uop, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode kloc in
            let c_uop = match uop with
                | OpPlus -> COpPlus
                | OpNegate -> COpNegate
                | OpBitwiseNot -> COpBitwiseNot
                | OpLogicNot -> COpLogicNot
                | OpDeref | OpMkRef | OpExpand | OpDotMinus | OpApos ->
                    raise_compile_err kloc (sprintf "cgen: unsupported unary op '%s'" (unop_to_string uop))
            in (true, CExpUnOp(c_uop, ce1, (ctyp, kloc)), ccode)
        | KExpIntrin(intr, args, _) ->
            (match (intr, args) with
            | (IntrinVariantTag, v :: []) ->
                let (cv, ccode) = atom2cexp v ccode kloc in
                let ktyp = get_atom_ktyp v kloc in
                let {ktp_ptr} = K_annotate_types.get_ktprops ktyp kloc in
                let extract_ctag = if ktp_ptr then
                        make_call !std_FX_REC_VARIANT_TAG [cv] CTypCInt kloc
                    else
                        cexp_mem cv (get_id "tag") CTypCInt
                    in
                let extract_ctag = match ktyp with
                    | KTypName tn -> (match (kinfo_ tn kloc) with
                        | KVariant {contents={kvar_flags; kvar_cases}} ->
                            let have_tag = kvar_flags.var_flag_have_tag in
                            let is_recursive = kvar_flags.var_flag_recursive in
                            let ncases = List.length kvar_cases in
                            if have_tag then extract_ctag
                            else if ncases = 1 && not is_recursive then
                                (make_int_exp 1 kloc)
                            else if ncases <= 2 && is_recursive then
                                CExpBinOp(COpCompareNE, cv, (make_nullptr kloc), (CTypBool, kloc))
                            else
                                raise_compile_err kloc "cgen: variants with no tag may have either 1 or 2 cases"
                        | _ -> raise_compile_err kloc (sprintf
                            "cgen: unexpected type '%s'; should be variant of exception"
                            (idk2str tn kloc)))
                    | _ -> extract_ctag
                    in
                (true, extract_ctag, ccode)
            | (IntrinVariantCase, v :: vn_val :: []) ->
                let (cv, ccode) = atom2cexp v ccode kloc in
                let vktyp = get_atom_ktyp v kloc in
                let {ktp_ptr} = K_annotate_types.get_ktprops vktyp kloc in
                (match (vktyp, vn_val) with
                | (KTypExn, (Atom.Id vn)) ->
                    (match (cinfo_ vn kloc) with
                    | CExn {contents={cexn_data}} ->
                        let exn_data = cexp_mem cv (get_id "data") CTypAny in
                        let exn_data = make_call (get_id "FX_EXN_DATA")
                            [CExpTyp ((CTypName cexn_data), kloc); exn_data] ctyp kloc in
                        (true, exn_data, ccode)
                    | _ -> raise_compile_err kloc (sprintf "cgen: information about exception '%s' is not found"
                        (idk2str vn kloc)))
                | (_, (Atom.Id vn)) ->
                    let vn_val = get_orig_id vn in
                    let cvu = if ktp_ptr then
                        cexp_arrow cv (get_id "u") CTypAny
                    else
                        cexp_mem cv (get_id "u") CTypAny in
                    let celem = cexp_mem cvu vn_val ctyp in
                    (true, celem, ccode)
                | _ -> raise_compile_err kloc "cgen: invalid IntrinVariantCase 2nd parameter")
            | (IntrinListHead, l :: []) ->
                let (cl, ccode) = atom2cexp l ccode kloc in
                (true, (cexp_arrow cl (get_id "hd") ctyp), ccode)
            | (IntrinListTail, l :: []) ->
                let (cl, ccode) = atom2cexp l ccode kloc in
                (true, (cexp_arrow cl (get_id "tl") ctyp), ccode)
            | (IntrinPopExn, []) ->
                let (dst_exp, ccode) = get_dstexp dstexp_r "curr_exn" CTypExn ccode kloc in
                let e = make_call (get_id "fx_exn_get_and_reset") [cexp_get_addr dst_exp] CTypVoid kloc in
                (false, dst_exp, (CExp e) :: ccode)
            | (IntrinStrConcat, al) ->
                let (strs, ccode) = List.fold_left (fun (strs, ccode) a ->
                    let (c_exp, ccode) = atom2cexp_ a true ccode kloc in
                    let s_exp = match (a, (get_cexp_typ c_exp)) with
                        | (Atom.Lit (LitChar s), CTypUniChar) ->
                            make_call (get_id "FX_MAKE_STR1") [make_lit_exp (LitString s) kloc] CTypString kloc
                        | ((Atom.Id n), CTypUniChar) ->
                            make_call (get_id "FX_MAKE_VAR_STR1") [c_exp] CTypString kloc
                        | _ -> c_exp
                        in
                    ((s_exp :: strs), ccode)) ([], ccode) al in
                let strs_id = gen_temp_idc "strs" in
                let strs_ctyp = CTypRawArray([CTypConst], CTypString) in
                let strs0 = CExpInit((List.rev strs), (strs_ctyp, kloc)) in
                let (dst_exp, ccode) = get_dstexp dstexp_r "concat_str" CTypString ccode kloc in
                let (strs_exp, sub_ccode) = create_cdefval strs_id strs_ctyp
                    (default_val_flags()) "" (Some strs0) [] kloc in
                let call_exp = make_call (get_id "fx_strjoin")
                    [make_nullptr kloc; make_nullptr kloc; make_nullptr kloc;
                    strs_exp; (make_int_exp (List.length strs) kloc); (cexp_get_addr dst_exp)] CTypInt kloc in
                let sub_ccode = add_fx_call call_exp sub_ccode kloc in
                let ccode = (rccode2stmt sub_ccode kloc) :: ccode in
                (false, dst_exp, ccode)
            | (IntrinGetSize, arr_or_str :: []) ->
                let (arr_exp, ccode) = atom2cexp arr_or_str ccode kloc in
                let c_e = match (get_atom_ktyp arr_or_str kloc) with
                | KTypString -> make_call (get_id "FX_STR_LENGTH") [arr_exp] CTypInt kloc
                | KTypArray _ -> make_call (get_id "FX_ARR_SIZE") [arr_exp; (make_int_exp 0 kloc)] CTypInt kloc
                | ktyp -> raise_compile_err kloc
                    (sprintf "cgen: unsupported container type %s of %s in KExpIntrin(IntrinGetSize...)"
                    (ktyp2str ktyp) (atom2str arr_or_str))
                in
                (true, c_e, ccode)
            | (IntrinGetSize, arr_or_str :: (Atom.Lit (LitInt i)) :: []) ->
                let (arr_exp, ccode) = atom2cexp arr_or_str ccode kloc in
                let c_e = match ((get_atom_ktyp arr_or_str kloc), i) with
                | (KTypString, 0L) -> make_call (get_id "FX_STR_LENGTH") [arr_exp] CTypInt kloc
                | (KTypArray(ndims, _), i) ->
                    if 0L <= i && i < (Int64.of_int ndims) then () else raise_compile_err kloc
                        (sprintf "array dimension index %Li is beyond dimensionality %d" i ndims);
                    make_call (get_id "FX_ARR_SIZE") [arr_exp; (make_int__exp i kloc)] CTypInt kloc
                | _ -> raise_compile_err kloc "cgen: unsupported container type in KExpIntrin(IntrinGetSize...)"
                in
                (true, c_e, ccode)
            | (IntrinCheckIdx, arrsz :: idx :: []) ->
                let lbl = curr_block_label kloc in
                let (arrsz_exp, ccode) = atom2cexp arrsz ccode kloc in
                let (idx_exp, ccode) = atom2cexp idx ccode kloc in
                let chk = make_call (get_id "FX_CHKIDX_SCALAR") [arrsz_exp; idx_exp; lbl] CTypVoid kloc in
                (false, dummy_exp, ((CExp chk) :: ccode))
            | (IntrinCheckIdxRange, arrsz :: a :: b :: delta :: scale :: shift :: []) ->
                let lbl = curr_block_label kloc in
                let (arrsz_exp, ccode) = atom2cexp arrsz ccode kloc in
                let (a_exp, ccode) = atom2cexp a ccode kloc in
                let (b_exp, ccode) = atom2cexp b ccode kloc in
                let (delta_exp, ccode) = atom2cexp delta ccode kloc in
                let (scale_exp, ccode) = atom2cexp scale ccode kloc in
                let (shift_exp, ccode) = atom2cexp shift ccode kloc in
                let chk = make_call (get_id "FX_CHKIDX_RANGE")
                    [arrsz_exp; a_exp; b_exp; delta_exp; scale_exp; shift_exp; lbl] CTypVoid kloc in
                (false, dummy_exp, ((CExp chk) :: ccode))
            | _ -> raise_compile_err kloc (sprintf "cgen: unsupported KExpIntrin(%s, ...)" (intrin2str intr)))
        | KExpSeq(el, _) ->
            let rec process_seq el ccode = match el with
                | [] -> (dummy_exp, ccode)
                | last :: [] -> kexp2cexp last dstexp_r ccode
                | e :: rest ->
                    let (_, ccode) = kexp2cexp e (ref None) ccode in
                    process_seq rest ccode
            in let (e, ccode) = process_seq el ccode in
            (false, e, ccode)
        | KExpIf(c, e1, e2, _) ->
            let (cc, ccode) = kexp2cexp c (ref None) ccode in
            let (dst_exp, ccode) = get_dstexp dstexp_r "t" ctyp ccode kloc in
            let (_, ccode1) = kexp2cexp e1 dstexp_r [] in
            let (_, ccode2) = kexp2cexp e2 dstexp_r [] in
            let c_e1 = rccode2stmt ccode1 (get_kexp_loc e1) in
            let c_e2 = rccode2stmt ccode2 (get_kexp_loc e2) in
            (false, dst_exp, (CStmtIf(cc, c_e1, c_e2, kloc)) :: ccode)

        | KExpCall(f, args, _) ->
            (*let _ = (printf "called function '%s'('%s') typ: " (id2str f) (idk2str f kloc); K_pp.pprint_ktyp_x ftyp_ kloc; printf "\n") in*)
            let (args, ccode) = List.fold_left (fun (args, ccode) arg ->
                let (carg, ccode) = atom2cexp arg ccode kloc in
                let carg = make_fun_arg carg kloc in
                (carg :: args, ccode)) ([], ccode) args
                in
            let (f, ci) = match (cinfo_ f kloc) with
                | CExn {contents={cexn_make}} -> (cexn_make, (cinfo_ cexn_make kloc))
                | ci -> (f, ci)
                in
            let (f_exp, have_out_arg, fv_args, is_nothrow, ccode) = match ci with
                | CFun cf ->
                    let {cf_args; cf_rt; cf_flags; cf_cname; cf_loc} = !cf in
                    let _ = ensure_sym_is_defined_or_declared f kloc in
                    let is_nothrow = cf_flags.fun_flag_nothrow in
                    let (_, ret_id, _, have_fv_arg) = unpack_fun_args cf_args cf_rt is_nothrow in
                    let f_exp = make_id_exp f cf_loc in
                    let fv_args =
                        if not have_fv_arg then
                            []
                        else if not cf_flags.fun_flag_uses_fv then
                            [make_lit_exp LitNil kloc]
                        else if f = (curr_func kloc) then
                            [make_id_t_exp (get_id "fx_fv") std_CTypVoidPtr cf_loc]
                        else
                            raise_compile_err kloc
                                (sprintf "cgen: %s '%s' %s %s" "cgen: looks like lambda lifting did not transform"
                                cf_cname "call correctly. Functions that access free variables must be called via closure"
                                "(except for the case when function calls itself)")
                        in
                    (f_exp, ret_id <> noid, fv_args, is_nothrow, ccode)
                | CVal {cv_typ; cv_flags; cv_loc} ->
                    let _ = if (is_val_global cv_flags) || (get_val_ctor cv_flags) <> noid then
                        ensure_sym_is_defined_or_declared f kloc else () in
                    let (fclo_exp, ccode) = id2cexp f false ccode kloc in
                    let ftyp = deref_ktyp (get_idk_ktyp f kloc) kloc in
                    let cftyp = C_gen_types.ktyp2ctyp ftyp kloc in
                    let f_exp = cexp_mem fclo_exp (get_id "fp") cftyp in
                    let fv_args = [cexp_mem fclo_exp (get_id "fcv") std_CTypVoidPtr] in
                    (f_exp, true, fv_args, false, ccode)
                | _ -> raise_compile_err kloc (sprintf "cgen: the called '%s' is not a function nor value" (id2str f))
                in
            if not have_out_arg && ctyp <> CTypVoid then
                let args = List.rev (fv_args @ args) in
                let call_exp = CExpCall(f_exp, args, (ctyp, kloc)) in
                (true, call_exp, ccode)
            else
                let (args, dst_exp, ccode) = if ctyp = CTypVoid then (args, dummy_exp, ccode) else
                    let (dst_exp, ccode) = get_dstexp dstexp_r "res" ctyp ccode kloc in
                    (((cexp_get_addr dst_exp) :: args), dst_exp, ccode)
                    in
                let args = List.rev (fv_args @ args) in
                let fcall_rt = if is_nothrow then CTypVoid else CTypCInt in
                let fcall_exp = CExpCall(f_exp, args, (fcall_rt, kloc)) in
                if is_nothrow then
                    (false, dst_exp, (CExp fcall_exp) :: ccode)
                else
                    let ccode = add_fx_call fcall_exp ccode kloc in
                    (false, dst_exp, ccode)

        | KExpMkTuple(args, _) | KExpMkRecord(args, _) ->
            let prefix = match kexp with KExpMkTuple(_, _) -> "tup" | _ -> "rec" in
            let tcon = C_gen_types.get_constructor ctyp false kloc in
            let (cargs, ccode) = List.fold_left (fun (cargs, ccode) a ->
                let (ca, ccode) = atom2cexp a ccode kloc in
                let ca = if tcon = noid then ca else make_fun_arg ca kloc in
                ((ca :: cargs), ccode)) ([], ccode) args in
            if tcon <> noid then
                let (t_exp, ccode) = get_dstexp dstexp_r prefix ctyp ccode kloc in
                let call_mktup = make_call tcon
                    ((List.rev cargs) @ [cexp_get_addr t_exp]) CTypVoid kloc in
                (false, t_exp, (CExp call_mktup) :: ccode)
            else
                let tup = gen_temp_idc prefix in
                let e0 = CExpInit((List.rev cargs), (ctyp, kloc)) in
                let (t_exp, ccode) = create_cdefval tup ctyp (default_val_flags()) "" (Some e0) ccode kloc in
                (true, t_exp, ccode)
        | KExpMkClosure(make_fp, f, args, _) ->
            let fp_prefix = ((pp_id2str f) ^ "_fp") in
            if args = [] && make_fp = noid then
                let fp_id = gen_temp_idc fp_prefix in
                let _ = ensure_sym_is_defined_or_declared f kloc in
                let f_exp = make_id_exp f kloc in
                let e0 = CExpInit([f_exp; (make_nullptr kloc)], (ctyp, kloc)) in
                let (fp_exp, ccode) = create_cdefval fp_id ctyp (default_val_flags()) "" (Some e0) ccode kloc in
                (true, fp_exp, ccode)
            else
                let (cargs, ccode) = List.fold_left (fun (cargs, ccode) a ->
                    let (ca, ccode) = atom2cexp a ccode kloc in
                    let ca = make_fun_arg ca kloc in
                    ((ca :: cargs), ccode)) ([], ccode) args in
                let (fp_exp, ccode) = get_dstexp dstexp_r fp_prefix ctyp ccode kloc in
                let _ = ensure_sym_is_defined_or_declared make_fp kloc in
                let call_mkclo = make_call make_fp
                    ((List.rev cargs) @ [cexp_get_addr fp_exp]) CTypVoid kloc in
                (false, fp_exp, (CExp call_mkclo) :: ccode)
        | KExpMkArray(arows, _) ->
            let have_expanded = List.exists (fun arow -> List.exists (fun (f, _) -> f) arow) arows in
            if have_expanded then
                let (arr_exp, ccode) = get_dstexp dstexp_r "arr" ctyp ccode kloc in
                let (dims, elem_ctyp) = match ctyp with
                    | CTypArray(dims, elem_ctyp) ->
                        (dims, elem_ctyp)
                    | _ -> raise_compile_err kloc "cgen: invalid output type of array construction expression"
                    in
                let scalars_id = gen_temp_idc "scalars" in
                let scalars_exp = make_id_t_exp scalars_id (make_ptr elem_ctyp) kloc in
                let (_, scalars_data, tags_data, arr_data, ccode) = List.fold_left
                    (fun (nscalars, scalars_data, tags_data, arr_data, ccode) arow ->
                        let (nscalars, scalars_data, tags_data, arr_data, ccode) = List.fold_left
                            (fun (nscalars, scalars_data, tags_data, arr_data, ccode) (f, a) ->
                                let (e, ccode) = atom2cexp a ccode kloc in
                                if f then
                                    let elem_ktyp = get_atom_ktyp a kloc in
                                    let (tag, elem_ptr) = match (deref_ktyp elem_ktyp kloc) with
                                        | KTypArray (d, _) -> (d, (cexp_get_addr e))
                                        | KTypList _ -> (100, e)
                                        | _ -> raise_compile_err kloc
                                            (sprintf "cgen: the expanded structure %s is not an array nor list" (atom2str a))
                                        in
                                    (nscalars, scalars_data, ((make_int_exp tag kloc) :: tags_data),
                                    (elem_ptr :: arr_data), ccode)
                                else
                                    let (nscalars, scalars_data, arr_data_elem) = match e with
                                        | CExpIdent _ -> (nscalars, scalars_data, (cexp_get_addr e))
                                        | _ -> (nscalars+1, (e :: scalars_data),
                                            CExpBinOp(COpAdd, scalars_exp, (make_int_exp nscalars kloc), (std_CTypVoidPtr, kloc)))
                                        in
                                    (nscalars, scalars_data, ((make_int_exp 0 kloc) :: tags_data),
                                    (arr_data_elem :: arr_data), ccode))
                            (nscalars, scalars_data, tags_data, arr_data, ccode) arow
                            in
                        (nscalars, scalars_data, ((make_int_exp 127 kloc) :: tags_data), arr_data, ccode))
                    (0, [], [], [], ccode) arows
                    in
                let (scalars_exp, sub_ccode) = decl_plain_arr scalars_id elem_ctyp (List.rev scalars_data) [] kloc in
                let tags_data = List.rev ((make_int_exp (-1) kloc) :: (List.tl tags_data)) in
                let (tags_exp, sub_ccode) = decl_plain_arr (gen_temp_idc "tags") (CTypSInt 8) tags_data sub_ccode kloc in
                let (arr_data_exp, sub_ccode) = decl_plain_arr (gen_temp_idc "parts") std_CTypVoidPtr
                    (List.rev arr_data) sub_ccode kloc in
                let sizeof_elem_exp = make_call !std_sizeof [CExpTyp(elem_ctyp, kloc)] CTypSize_t kloc in
                let free_f_exp = match (C_gen_types.get_free_f elem_ctyp true false kloc) with
                    | (_, (Some free_f)) -> CExpCast(free_f, !std_fx_free_t, kloc)
                    | _ -> make_nullptr kloc
                    in
                let copy_f_exp = match (C_gen_types.get_copy_f elem_ctyp true false kloc) with
                    | (_, Some(copy_f)) -> CExpCast(copy_f, !std_fx_copy_t, kloc)
                    | _ -> make_nullptr kloc
                    in
                let call_mkarr = make_call (get_id "fx_compose_arr") [(make_int_exp dims kloc);
                    sizeof_elem_exp; free_f_exp; copy_f_exp; tags_exp; arr_data_exp; (cexp_get_addr arr_exp)] CTypCInt kloc
                    in
                let sub_ccode = add_fx_call call_mkarr sub_ccode kloc in
                let ccode = (rccode2stmt sub_ccode kloc) :: ccode in
                (false, arr_exp, ccode)
            else
                let nrows = List.length arows in
                let ncols = List.length (List.hd arows) in
                let shape = if nrows > 1 then [nrows; ncols] else [ncols] in
                let shape = List.map (fun i -> make_int_exp i kloc) shape in
                let (data, ccode) = List.fold_left (fun (data, ccode) arow ->
                    List.fold_left (fun (data, ccode) (_, a) ->
                        let (e, ccode) = atom2cexp a ccode kloc in
                        (e :: data, ccode)) (data, ccode) arow)
                    ([], ccode) arows in
                let (arr_exp, ccode) = decl_arr ctyp shape (List.rev data) dstexp_r ccode kloc in
                (false, arr_exp, ccode)
        | KExpAt(arr, border, interp, idxs, _) ->
            (*
                there are 2 major cases:
                1. some of the idxs are ranges. Then the result is fx_arr_t
                2. all the ranges are scalars. Then the result is array element

                1. In the first case need to call a special function
                    `FX_CALL(fx_subarr(arr, ranges, subarr));`.
                    where ranges is array, concatenation of the following groups:
                    (0, idx) scalar indices
                    (1, a, b, delta) closed ranges [a:b:delta]
                        (if a was missing, it's set to 0, if delta was missing, it's set to 1)
                    (2, a, delta) open ranges [a::delta]
                        (if delta was missing, it's set to 1)
                1.1. special case if a single [:] range, which means flattening operation.
                    just call fx_flatten_arr().

                2. In the second case need first to process each index idx_k (k=0..ndims-1):
                   2.1. If idx_k is "fast index" - great, just use the expression for the index
                        (process it via `atom2cexp`)
                   2.2. Otherwise we need to use the index more than once, so we need to
                        store it to temporary variable (unless it's already an indentifier or constant)
                        and add it to the check
                        `FX_CHKIDX(FX_CHKIDX1(arr, k1, idx_k1) && FX_CHKIDX1(arr, k2, idx_k2) ..., catch_label);`
                    if all the indices are fast indices, the whole check is excluded, of course.
                    then we return `(true, FX_PTR_{ndims}D(elem_ctyp, arr, idx0, ..., idx{ndims-1}), ccode)`
            *)
            let _ = if border = BorderNone then () else
                raise_compile_err kloc "cgen: border extrapolation is not supported yet" in
            let _ = if interp = InterpNone then () else
                raise_compile_err kloc "cgen: inter-element interpolation is not supported yet" in
            let (arr_exp, ccode) = atom2cexp_ arr false ccode kloc in
            let lbl = curr_block_label kloc in
            let arr_ctyp = get_cexp_typ arr_exp in
            (match arr_ctyp with
            | CTypString ->
                (match idxs with
                | Domain.Fast i :: [] ->
                    let (i_exp, ccode) = atom2cexp i ccode kloc in
                    let get_elem_exp = make_call !std_FX_STR_ELEM [arr_exp; i_exp] CTypUniChar kloc in
                    (true, get_elem_exp, ccode)
                | Domain.Elem i :: [] ->
                    let (i_exp, ccode) = atom2cexp_ i true ccode kloc in
                    let chk_exp = make_call !std_FX_STR_CHKIDX [arr_exp; i_exp; lbl] CTypBool kloc in
                    let get_elem_exp = make_call !std_FX_STR_ELEM [arr_exp; i_exp] CTypUniChar kloc in
                    (true, get_elem_exp, (CExp chk_exp) :: ccode)
                | Domain.Range(a, b, delta) :: [] ->
                    let (mask, (a_exp, ccode)) = match a with
                        | Atom.Lit LitNil -> (1, ((make_int_exp 0 kloc), ccode))
                        | _ -> (0, (atom2cexp a ccode kloc))
                        in
                    let (mask, (b_exp, ccode)) = match b with
                        | Atom.Lit LitNil -> (2+mask, ((make_int_exp 0 kloc), ccode))
                        | _ -> (mask, (atom2cexp b ccode kloc))
                        in
                    let (delta_exp, ccode) = atom2cexp delta ccode kloc in
                    let (substr_exp, ccode) = get_dstexp dstexp_r "substr" ctyp ccode kloc in
                    let call_substr = make_call !std_fx_substr
                        [(cexp_get_addr arr_exp); a_exp; b_exp; delta_exp; (make_int_exp mask kloc);
                            (cexp_get_addr substr_exp)] CTypCInt kloc in
                    (false, substr_exp, (add_fx_call call_substr ccode kloc))
                | _ -> raise_compile_err kloc
                    "cgen: unexpected index type when accessing string (should be a single scalar index or range)")
            | CTypArray _ ->
                let need_subarr = List.exists (fun d -> match d with Domain.Range _ -> true | _ -> false) idxs in
                let need_flatten = need_subarr && (match idxs with
                    | Domain.Range((Atom.Lit LitNil), (Atom.Lit LitNil), (Atom.Lit LitNil)) :: []
                    | Domain.Range((Atom.Lit LitNil), (Atom.Lit LitNil), (Atom.Lit (LitInt 1L))) :: [] -> true
                    | _ -> false)
                    in
                if need_flatten then
                    let (subarr_exp, _) = get_dstexp dstexp_r "arr" ctyp ccode kloc in
                    let call_flatten = make_call (get_id "fx_flatten_arr")
                        [(cexp_get_addr arr_exp); (cexp_get_addr subarr_exp)] CTypCInt kloc in
                    (false, subarr_exp, (add_fx_call call_flatten ccode kloc))
                else if need_subarr then
                    let (range_data, ccode) = List.fold_left (fun (range_data, ccode) d ->
                        match d with
                        | Domain.Elem i | Domain.Fast i ->
                            let (i_exp, ccode) = atom2cexp i ccode kloc in
                            ((i_exp :: (make_int_exp 0 kloc) :: range_data), ccode)
                        | Domain.Range (a, b, delta) ->
                            let (a_exp, ccode) =
                                match a with
                                | Atom.Lit LitNil -> ((make_int_exp 0 kloc), ccode)
                                | _ -> atom2cexp a ccode kloc
                                in
                            let (range_delta, ccode) = match b with
                                | Atom.Lit LitNil -> ((a_exp :: (make_int_exp 2 kloc) :: []), ccode)
                                | _ ->
                                    let (b_exp, ccode) = atom2cexp b ccode kloc in
                                    ((b_exp :: a_exp :: (make_int_exp 1 kloc) :: []), ccode)
                                in
                            let (d_exp, ccode) = atom2cexp delta ccode kloc in
                            (((d_exp :: range_delta) @ range_data), ccode)) ([], ccode) idxs
                        in
                    let (subarr_exp, ccode) = get_dstexp dstexp_r "arr" ctyp ccode kloc in
                    let rdata_ctyp = CTypRawArray ([CTypConst], CTypInt) in
                    let rdata_arr = CExpInit((List.rev range_data), (rdata_ctyp, kloc)) in
                    let (rdata_exp, sub_ccode) = create_cdefval (gen_temp_idc "ranges") rdata_ctyp
                        (default_val_flags()) "" (Some rdata_arr) [] kloc in
                    let call_subarr = make_call !std_fx_subarr [(cexp_get_addr arr_exp);
                        rdata_exp; (cexp_get_addr subarr_exp)] CTypInt kloc in
                    let sub_ccode = add_fx_call call_subarr sub_ccode kloc in
                    let ccode = (rccode2stmt sub_ccode kloc) :: ccode in
                    (false, subarr_exp, ccode)
                else
                    let elem_ctyp = ctyp in
                    let (_, chk_exp_opt, i_exps, ccode) = List.fold_left (fun (dim, chk_exp_opt, i_exps, ccode) d ->
                        match d with
                        | Domain.Fast i ->
                            let (i_exp, ccode) = atom2cexp i ccode kloc in
                            (dim+1, chk_exp_opt, i_exp :: i_exps, ccode)
                        | Domain.Elem i ->
                            let (i_exp, ccode) = atom2cexp_ i true ccode kloc in
                            let chk_exp1 = make_call !std_FX_CHKIDX1 [arr_exp; (make_int_exp dim kloc); i_exp] CTypBool kloc in
                            let chk_exp_opt = match chk_exp_opt with
                                | Some(chk_exp) ->
                                    let chk_exp = CExpBinOp(COpLogicAnd, chk_exp, chk_exp1, (CTypBool, kloc)) in
                                    Some chk_exp
                                | _ -> Some(chk_exp1)
                                in
                            (dim+1, chk_exp_opt, i_exp :: i_exps, ccode)
                        | _ -> raise_compile_err kloc "cgen: unexpected index type")
                        (0, None, [], ccode) idxs
                        in
                    let ccode = match chk_exp_opt with
                        | Some (chk_exp) ->
                            let call_chkidx = make_call !std_FX_CHKIDX [chk_exp; lbl] CTypVoid kloc in
                            (CExp call_chkidx) :: ccode
                        | _ -> ccode
                        in
                    let ndims = List.length idxs in
                    let get_elem_exp = make_call (List.nth (!std_FX_PTR_xD) (ndims-1))
                        (CExpTyp (elem_ctyp,kloc) :: arr_exp :: (List.rev i_exps)) (make_ptr elem_ctyp) kloc in
                    (true, (cexp_deref get_elem_exp), ccode)
            | _ -> raise_compile_err kloc "unknown/unsupported type of the container, should be CTypArray _ or CTypString")
        | KExpMem(a1, n, _) ->
            let (ce1, ccode) = id2cexp a1 false ccode kloc in
            let (_, ce1, relems, ofs) = get_struct ce1 in
            let nelems = List.length relems in
            let _ = if n < 0 || n+ofs >= nelems then
                raise_compile_err kloc (sprintf "cgen: the tuple/record element index %d is out of range [0, %d]" n nelems)
                else () in
            let (n_id, _) = List.nth relems (n+ofs) in
            (true, (cexp_mem ce1 n_id ctyp), ccode)
        | KExpAssign(i, a, _) ->
            let ktyp = get_idk_ktyp i kloc in
            let {ktp_complex} = K_annotate_types.get_ktprops ktyp kloc in
            let ccode =
                if ktp_complex then
                    let (i_exp, ccode) = id2cexp i true ccode kloc in
                    let (e_exp, ccode) = atom2cexp_ a true ccode kloc in
                    let ctyp = get_cexp_typ i_exp in
                    (if is_subarray i kloc then
                        let copy_arr_data = make_call !std_fx_copy_arr_data [(cexp_get_addr e_exp);
                            (cexp_get_addr i_exp); (make_bool_exp true kloc)] CTypInt kloc in
                        add_fx_call copy_arr_data ccode kloc
                    else
                        (* if "i" occurs in "e2", we need to be safe and free "i" only after "e2" is computed *)
                        let ccode = C_gen_types.gen_free_code i_exp ctyp true false ccode kloc in
                        C_gen_types.gen_copy_code e_exp i_exp ctyp ccode kloc)
                else
                    (* if the type is simple, copy it rhs directly to lhs *)
                    let (i_exp, ccode) = id2cexp i false ccode kloc in
                    let (a_exp, ccode) = atom2cexp a ccode kloc in
                    C_gen_types.gen_copy_code a_exp i_exp ctyp ccode kloc
                in
            (false, dummy_exp, ccode)
        | KExpMatch(cases, _) ->
            (*
            code00; if(exp00) {
                code01; if(exp01) {
                ... if(exp0N0) {
                    action0; goto _fx_endmatch...;
            }...}}
            code10; if(exp01) {
                code11; if(exp11) {
                ... if(exp1N1) {
                    action1; goto _fx_endmatch...;
            }...}}
            ...
            #if <have_default_action>
            default_action; // if there is default case
            #else
            FX_THROW_FAST(FX_EXN_NoMatchError, parent_label);
            #endif
            [_fx_endmatch...:]
            ...
            *)
            let (dst_exp, ccode) = get_dstexp dstexp_r "res" ctyp ccode kloc in
            let ccode = process_cases cases dstexp_r ccode false kloc in
            (false, dst_exp, ccode)

        | KExpTryCatch(try_e, catch_e, _) ->
            (*
            [dst_exp =] try_block
            if(fx_status < 0) {
                fx_status = 0;
                [destruct dst_exp] // because it maybe partially constructed at this point,
                                   // but we are going to re-use it
                catch_code
            }
            *)
            let (dst_exp, ccode) = get_dstexp dstexp_r "res" ctyp ccode kloc in
            let try_loc = get_kexp_loc try_e in
            let try_end_loc = get_end_loc try_loc in
            let _ = new_block_ctx BlockKind_Try try_loc in
            let (_, try_ccode) = kexp2cexp try_e dstexp_r [] in
            let bctx_try = curr_block_ctx kloc in
            let {bctx_prologue; bctx_cleanup; bctx_label; bctx_label_used} = bctx_try in
            let epilogue =
                if bctx_label_used = 0 then bctx_cleanup
                else bctx_cleanup @ (CStmtLabel (bctx_label, try_end_loc) :: [])
                in
            let ccode = epilogue @ try_ccode @ bctx_prologue @ ccode in
            let _ = pop_block_ctx try_end_loc in
            let fx_status_exp = make_fx_status try_end_loc in
            let catch_ccode = [CExp (CExpBinOp(COpAssign, fx_status_exp,
                (make_int_exp 0 try_end_loc), (CTypVoid, try_end_loc)))] in
            let catch_ccode = match ctyp with
                | CTypVoid -> catch_ccode
                | _ -> C_gen_types.gen_free_code dst_exp ctyp true true catch_ccode try_end_loc
                in
            let (_, catch_ccode) = kexp2cexp catch_e dstexp_r catch_ccode in
            let check_neg_status = CExpBinOp(COpCompareLT, (make_fx_status try_end_loc),
                (make_int_exp 0 try_end_loc), (CTypBool, try_end_loc)) in
            let catch_loc = get_kexp_loc catch_e in
            let catch_clause = CStmtIf(check_neg_status,
                (rccode2stmt catch_ccode catch_loc), (CStmtNop try_end_loc), catch_loc) in
            (false, dst_exp, catch_clause :: ccode)
        | KExpThrow(i, rethrow, _) ->
            let lbl = curr_block_label kloc in
            let ccode = if rethrow then
                let (i_exp, ccode) = id2cexp i false ccode kloc in
                let throw_exp = make_call !std_FX_RETHROW [(cexp_get_addr i_exp); lbl] CTypVoid kloc in
                (CExp throw_exp) :: ccode
            else match Hashtbl.find_all builtin_exceptions i with
            | [] ->
                let move_f = match (kinfo_ i kloc) with
                    | KExn _ -> false
                    | KVal {kv_typ=KTypExn} -> IdSet.mem i u1vals
                    | _ -> raise_compile_err kloc
                        "cgen: throw is applied to neither exception nor value of 'exn' type"
                    in
                let (i_exp, ccode) = id2cexp i move_f ccode kloc in
                let throw_exp = make_call !std_FX_THROW
                    [(cexp_get_addr i_exp); (make_bool_exp move_f kloc); lbl] CTypVoid kloc in
                (CExp throw_exp) :: ccode
            | _ ->
                let i = get_id ("FX_EXN_" ^ (pp_id2str i)) in
                let i_exp = make_id_t_exp i CTypCInt kloc in
                let throw_exp = make_call !std_FX_FAST_THROW [i_exp;lbl] CTypVoid kloc in
                (CExp throw_exp) :: ccode
                in
            (false, dummy_exp, ccode)
        | KExpCast(a1, kt, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode kloc in
            let ctyp = C_gen_types.ktyp2ctyp kt kloc in
            (true, CExpCast(ce1, ctyp, kloc), ccode)
        | KExpMap(e_idoml_l, body, flags, _) ->
            (*
                1. generate output collection (`arr/list_first = get_dstexp).
                   in the case of list also declare `_fx_L... list_last=0;`
                2. make list of expressions before each for in the comprehension, starting from the outer loop:
                    pre_e1 :: pre_e2 ... :: pre_body :: []
                   at once compute the output dimensionality
                3. define recursive function:
                    run process_for
                    if it's the inner-most loop and if we make array,
                        check the size of array if it is already created,
                        otherwise create the array.
                    if we make array, but there are just lists
                    form nested scope
                    form nested_ccode (see KExpFor, how body_ccode is formed)
                    if there are no more nested fors,
                        call `result=get_dstexp...` to store the body expression result.
                        gen ccode for the body.
                        if we make array,
                            check that there are no break or continue statement inside for.
                            form `*dstptr++ = result;` expression
                        otherwise (we make list)
                            create list cell (no need to put it to prologue, because we are not going to release it)
                            _fx_L... list_cell;
                            FX_CALL(_fx_make_L...(result, 0, &list_cell), end_loop);
                            FX_LIST_APPEND(list_first, list_last, list_cell);
                        finalize loop, make CExp (CExpFor(...)) :: []
                    else
                        call function recursively, get for-loop with attached parts.
                    return post_ccode :: (formed_for_loop @ init_ccode)
                4. pass there everything, append the result to ccode.
                5. return (false, arr/list_exp, ccode)
            *)
            let map_lbl = curr_block_label kloc in
            let for_loc = get_start_loc kloc in
            let end_for_loc = get_end_loc kloc in
            let need_make_list = flags.for_flag_make = ForMakeList in
            let need_make_array = flags.for_flag_make = ForMakeArray in
            let nfors = List.length e_idoml_l in
            (* collect all the variables/values declared inside for (include iterations variables) *)
            let (pre_alloc_array, _) = if not need_make_array then (false, IdSet.empty) else
                List.fold_left (fun (pre_alloc_array, decl_inside_for) (e, idoml, idxl) ->
                    if not pre_alloc_array then
                        (pre_alloc_array, decl_inside_for)
                    else
                        let decl_inside_for = List.fold_left (fun decl_inside_for i ->
                            IdSet.add i decl_inside_for) decl_inside_for idxl in
                        let (_, decl_inside_e) = used_decl_by_kexp e in
                        let decl_inside_for = IdSet.union decl_inside_for decl_inside_e in
                        List.fold_left (fun (pre_alloc_array, decl_inside_for) (i, dom) ->
                            let decl_inside_for = IdSet.add i decl_inside_for in
                            let pre_alloc_array = (match dom with
                                | Domain.Elem (Atom.Id col) ->
                                    let {kv_typ; kv_flags} = get_kval col kloc in
                                    if not kv_flags.val_flag_mutable &&
                                        (match kv_typ with KTypArray _ | KTypString -> true | _ -> false) &&
                                        not (IdSet.mem col decl_inside_for) then
                                        pre_alloc_array else false
                                | Domain.Elem (Atom.Lit (LitString _)) -> pre_alloc_array
                                | Domain.Range (a, b, delta) ->
                                    let check_range_elem e =
                                        match e with
                                        | Atom.Id k ->
                                            if (is_mutable k kloc) || (IdSet.mem k decl_inside_for)
                                            then false
                                            else pre_alloc_array
                                        | _ -> pre_alloc_array
                                        in
                                    (check_range_elem a) &&
                                    (check_range_elem b) &&
                                    (check_range_elem delta)
                                | _ -> false)
                                in
                        (pre_alloc_array, decl_inside_for)) (true, decl_inside_for) idoml)
                (true, IdSet.empty) e_idoml_l
            in
            (* compute the total array dimensionality *)
            let (_, ndims) = List.fold_left
                (fun (for_idx, ndims) (e, idoml, _) ->
                    let ndims_i = compute_for_ndims for_idx nfors idoml for_loc in
                    (for_idx+1, ndims + ndims_i)) (0, 0) e_idoml_l
                in
            let is_parallel_map = pre_alloc_array && flags.for_flag_parallel in
            let glob_status = make_id_t_exp (get_id "fx_status") CTypCInt kloc in
            let (par_status, ccode, nested_status, decl_nested_status) = if is_parallel_map then
                    let (par_status, ccode) = create_cdefval (gen_temp_idc "par_status")
                        CTypCInt (default_var_flags()) "" (Some (make_int_exp 0 kloc)) ccode kloc in
                    let (nested_status, decl_nested_status) = create_cdefval (gen_temp_idc "status")
                        CTypCInt (default_var_flags()) "fx_status" (Some (make_int_exp 0 kloc)) [] kloc in
                    (par_status, ccode, nested_status, decl_nested_status)
                else
                    ((make_dummy_exp kloc), ccode, glob_status, [])
                in
            (* declare the output array/list; in the case of array also declare the output pointer;
               in the case of list also declare pointer to the last list element *)
            let (elemtyp, dst_exp, dstptr, lstend, ccode) =
                match (need_make_array, need_make_list, ctyp, (deref_ktyp ktyp for_loc)) with
                | (true, false, CTypArray(nd, elemtyp), KTypArray _) ->
                    let (dst_exp, ccode) = get_dstexp dstexp_r "arr" ctyp ccode for_loc in
                    let (dst_ptr, ccode) =
                        if is_parallel_map then
                            ((make_dummy_exp kloc), ccode)
                        else
                            create_cdefval (gen_temp_idc "dstptr") (make_ptr elemtyp)
                                (default_var_flags()) "" (Some (make_nullptr for_loc)) ccode for_loc
                        in
                    if nd <> ndims then
                        raise_compile_err kloc
                        (sprintf "cgen: invalid dimensionaly of array comprehension result (computed: %d, expected: %d)" ndims nd)
                    else (elemtyp, dst_exp, dst_ptr, (make_dummy_exp for_loc), ccode)
                | (false, true, _, KTypList kelemtyp) ->
                    let elemtyp = C_gen_types.ktyp2ctyp kelemtyp for_loc in
                    let (dst_exp, ccode) = get_dstexp dstexp_r "lst" ctyp ccode for_loc in
                    let (lst_end, ccode) = create_cdefval (gen_temp_idc "lstend") ctyp
                        (default_var_flags()) "" (Some (make_nullptr for_loc)) ccode for_loc in
                    (elemtyp, dst_exp, (make_dummy_exp for_loc), lst_end, ccode)
                | _ -> raise_compile_err kloc (sprintf
                    "cgen: invalid combination of comprehension type (%s) and the output collection type"
                    (if need_make_array then "MAKE_ARRAY" else if need_make_list then "MAKE_LIST" else "???"))
                in
            (* for the nested for statement *)
            let rec form_map pre_map_ccode for_idx e_idoml_l prev_i_exps prev_n_exps =
                let (init_kexp, idoml, at_ids, nested_e_idoml) =
                    match e_idoml_l with
                    | (e, idoml, at_ids) :: rest -> (e, idoml, at_ids, rest)
                    | _ -> raise_compile_err for_loc "cgen: empty e_idoml_l in KExpMap"
                    in
                let dims_ofs = List.length prev_n_exps in
                let nested_loc = get_kexp_loc init_kexp in
                let nested_loc = if nested_loc = noloc then for_loc else nested_loc in
                let (_, init_ccode) = kexp2cexp init_kexp (ref None) [] in
                let lbl = curr_block_label nested_loc in
                let (for_headers, list_exps, i_exps, n_exps, pre_map_ccode_delta, pre_body_ccode, body_elems, post_ccode) =
                    process_for lbl idoml at_ids for_idx nfors ndims dims_ofs nested_e_idoml [] nested_loc in
                let (ndims_i, n_exps, lst_len_ccode) = match (list_exps, n_exps, need_make_array) with
                    | (_, n_exp :: _, _) -> ((List.length n_exps), n_exps, [])
                    | (l_exp :: _, [], true) ->
                        (* if there is no fixed range or array iterated, just list(s),
                           and we need to make array, we need to compute length of the list. *)
                        let call_list_len = make_call !std_fx_list_length [l_exp] CTypInt nested_loc in
                        let (lstlen, lst_len_ccode) = create_cdefval (gen_temp_idc "len")
                            CTypInt (default_val_flags()) "" (Some call_list_len) [] nested_loc in
                        (1, [lstlen], lst_len_ccode)
                    | ([], [], true) ->
                        raise_compile_err nested_loc
                            (for_err_msg for_idx nfors (-1) "array comprehension uses 'for' with indefinite range")
                    | _ -> (1, n_exps, [])
                    in
                let n_exps = prev_n_exps @ n_exps in
                let i_exps = prev_i_exps @ i_exps in
                let alloc_array_ccode = if (not need_make_array) || (dims_ofs + ndims_i < ndims) then [] else
                    let (_, cmp_size_list) = List.fold_left (fun (k, cmp_size_list) n_exp ->
                        let size_i = make_call !std_FX_ARR_SIZE [dst_exp; (make_int_exp k nested_loc)] CTypInt nested_loc in
                        let cmp_size_i = CExpBinOp(COpCompareEQ, size_i, n_exp, (CTypBool, nested_loc)) in
                        (k+1, cmp_size_i :: cmp_size_list)) (0, []) n_exps
                        in
                    let lbl = if pre_alloc_array then map_lbl else (curr_block_label nested_loc) in
                    let then_ccode = make_make_arr_call dst_exp n_exps [] [] lbl nested_loc in
                    let then_ccode =
                        if is_parallel_map then
                            then_ccode
                        else
                            let arr_data = CExpCast((cexp_mem dst_exp (get_id "data") std_CTypVoidPtr),
                                (make_ptr elemtyp), nested_loc) in
                            let set_dstptr = make_assign dstptr arr_data in
                            (CExp set_dstptr) :: then_ccode
                        in
                    if for_idx = 0 || pre_alloc_array then
                        then_ccode
                    else
                        let cc_exp = cexp_mem dst_exp (get_id "data") std_CTypVoidPtr in
                        let cc_exp = CExpUnOp(COpLogicNot, cc_exp, (CTypBool, nested_loc)) in
                        let else_ccode = add_size_eq_check cmp_size_list [] lbl nested_loc in
                        let check_or_create = CStmtIf(cc_exp,
                            (rccode2stmt then_ccode nested_loc),
                            (rccode2stmt else_ccode nested_loc), nested_loc) in
                        check_or_create :: []
                    in
                let (pre_map_ccode, init_ccode) =
                    if pre_alloc_array then
                        ((alloc_array_ccode @ pre_map_ccode_delta @ pre_map_ccode), (lst_len_ccode @ init_ccode))
                    else
                        (pre_map_ccode, (alloc_array_ccode @ lst_len_ccode @ pre_map_ccode_delta @ init_ccode))
                    in
                let for_flags = {(default_for_flags()) with
                    for_flag_nested=for_idx > 0;
                    for_flag_parallel=is_parallel_map && for_idx <= 0} in
                let _ = new_for_block_ctx ndims for_flags nested_status par_status kloc in
                (* inside the loop body context form `<etyp> v=e` expressions (or more complex ones in the case of complex types) *)
                let body_ccode = decl_for_body_elems body_elems [] in
                let (add_incr_dstptr, dstptr, pre_body_ccode, (pre_map_ccode, body_ccode)) = match nested_e_idoml with
                    | (body, [], []) :: [] ->
                        (* add the loop body itself *)
                        let body_loc = get_kexp_loc body in
                        let (add_incr_dstptr, dstptr, pre_body_ccode, body_ccode) =
                            if not is_parallel_map then
                                (true, dstptr, pre_body_ccode, body_ccode)
                            else
                                let n_i_exps = List.length i_exps in
                                let _ = if n_i_exps = (List.length n_exps) && n_i_exps = ndims then () else
                                    raise_compile_err body_loc
                                    (sprintf
                                    "cgen: internal error when compiling parallel for: incorrect number of iteration indices (=%d). There should be as many as the output array dimensionality (=%d)"
                                    n_i_exps ndims)
                                    in
                                let elemtyp_ptr = make_ptr elemtyp in
                                let dst_idxs = if ndims = 1 then i_exps else
                                    List.rev ((make_int_exp 0 body_loc) :: (List.tl (List.rev i_exps))) in
                                let get_arr_slice = make_call (List.nth (!std_FX_PTR_xD) (ndims-1))
                                    (CExpTyp (elemtyp, body_loc) :: dst_exp :: dst_idxs) elemtyp_ptr body_loc in
                                let (dstptr, decl_dstptr_ccode) =
                                    create_cdefval (gen_temp_idc "dstptr") elemtyp_ptr
                                        (default_var_flags()) "" (Some get_arr_slice) [] body_loc in
                                if ndims = 1 then (false, dstptr, pre_body_ccode, (decl_dstptr_ccode @ body_ccode))
                                else (true, dstptr, (decl_dstptr_ccode @ pre_body_ccode), body_ccode)
                            in

                        let (result, body_ccode) = kexp2cexp body (ref None) body_ccode in

                        (* [TODO] if the result is temporarily created value, then it would be more efficient
                               to "move" it to the output collection instead of copying it there:
                            1. the result should be local variable that is defined in the body prologue
                               (which means that it's temporary and it's complex).
                               Note that it is compile-time check, not runtime check.
                               If the result is not complex, we don't call destructor and use simple '=' operator,
                               no need to bother with move.
                            2. we update C_gen_types.get_ctprops to return move macro
                               (FX_MOVE_STR, FX_MOVE_ARR, FX_MOVE_PTR, FX_MOVE_RECORD
                               (the last one is universal macro)).
                               we use move_macro(result, *dstptr).
                               We still need to retain conditional destructor call for 'result',
                               but it will do nothing (and the check will be perfectly predicted,
                               because it will _always_ do nothing, except for the exceptional situations)
                            3. (optional: we need to extend _fx_cons_L...() implementation:
                                add `bool move_hd` parameter), otherwise we use this 'move' trick
                                only with array comprehensions.
                        *)
                        if need_make_array then
                            (add_incr_dstptr, dstptr, pre_body_ccode,
                                (pre_map_ccode, (C_gen_types.gen_copy_code result
                                    (cexp_deref dstptr) elemtyp body_ccode body_loc)))
                        else
                            let (node_exp, body_ccode) = create_cdefval (gen_temp_idc "node") ctyp
                                (default_val_flags()) "" (Some (make_nullptr body_loc)) body_ccode body_loc in
                            let body_ccode = make_cons_call result (make_nullptr body_loc)
                                false node_exp body_ccode body_loc in
                            let append_call = make_call !std_FX_LIST_APPEND [dst_exp; lstend; node_exp] CTypVoid body_loc in
                            (false, dstptr, pre_body_ccode, (pre_map_ccode, ((CExp append_call) :: body_ccode)))
                    | _ ->
                        (false, dstptr, pre_body_ccode, (form_map pre_map_ccode (for_idx+1) nested_e_idoml i_exps n_exps))
                    in
                (* add the initialization and the cleanup sections, if needed *)
                let (br_label, body_stmt) = finalize_loop_body body_ccode (not need_make_array) kloc in

                (* form (possibly nested) for statement *)
                let nfor_headers = List.length for_headers in
                let (_, for_ccode) = List.fold_left (fun (k, for_ccode) (t_opt, for_inits, for_check_opt, for_incrs) ->
                    let for_incrs = if k > 0 || (not add_incr_dstptr) then for_incrs else
                        for_incrs @ [CExpUnOp(COpSuffixInc, dstptr, (CTypVoid, for_loc))]
                        in
                    let insert_pragma = for_idx = 0 && is_parallel_map && k+1 = nfor_headers in
                    let for_body_ccode = if not insert_pragma then for_ccode else
                        for_ccode @ decl_nested_status in
                    let (t_opt, init_t_opt) =
                        match (t_opt, insert_pragma, post_ccode) with
                        | ((Some _), false, _ :: _) -> (None, t_opt)
                        | _ -> (t_opt, None)
                        in
                    let for_ccode = match init_t_opt with
                        | Some(t) ->
                            List.fold_left (fun for_ccode e ->
                                match e with
                                | CExpBinOp(COpAssign, CExpIdent(i, (_, loc_i)), _, _) ->
                                    CDefVal(t, i, None, loc_i) :: for_ccode
                                | e ->
                                    raise_compile_err (get_cexp_loc e)
                                        "invalid expression in the for-loop initialization part (should be i=<exp0>)"
                            ) [] for_inits
                        | _ -> []
                        in
                    let for_ccode = (CStmtFor(t_opt, for_inits, for_check_opt, for_incrs, (rccode2stmt for_body_ccode kloc), kloc)) :: for_ccode in
                    let for_ccode = if not insert_pragma then for_ccode else
                        for_ccode @ [CMacroPragma("omp parallel for", kloc)]
                        in
                    let for_ccode = if k > 0 || pre_body_ccode = [] then for_ccode else for_ccode @ pre_body_ccode in
                    (k+1, for_ccode)) (0, (List.rev (stmt2ccode body_stmt))) (List.rev for_headers)
                in
                (* add the non-local "break" label if needed *)
                let post_ccode = if br_label = noid then post_ccode else (CStmtLabel(br_label, end_for_loc)) :: post_ccode in
                (pre_map_ccode, (post_ccode @ for_ccode @ init_ccode))
            in
            let (pre_map_ccode, map_ccode) = form_map [] 0 (e_idoml_l@[(body, [], [])]) [] [] in
            let map_ccode = if not is_parallel_map then map_ccode else
                add_fx_call par_status map_ccode kloc
                in
            (false, dummy_exp, map_ccode @ pre_map_ccode @ ccode)
        | KExpFor(idoml, at_ids, body, flags, _) ->
            let lbl = curr_block_label kloc in
            let for_loc = get_start_loc kloc in
            let end_for_loc = get_end_loc kloc in
            let ndims = compute_for_ndims 0 1 idoml for_loc in
            let glob_status = make_id_t_exp (get_id "fx_status") CTypCInt kloc in
            let is_parallel_for = flags.for_flag_parallel in
            let (par_status, ccode, nested_status, decl_nested_status) = if is_parallel_for then
                    let (par_status, ccode) = create_cdefval (gen_temp_idc "par_status")
                        CTypCInt (default_var_flags()) "" (Some (make_int_exp 0 kloc)) ccode kloc in
                    let (nested_status, decl_nested_status) = create_cdefval (gen_temp_idc "status")
                        CTypCInt (default_var_flags()) "fx_status" (Some (make_int_exp 0 kloc)) [] kloc in
                    (par_status, ccode, nested_status, decl_nested_status)
                else
                    ((make_dummy_exp kloc), ccode, glob_status, [])
                in
            let (for_headers, _, _, _, ccode, pre_body_ccode, body_elems, post_ccode) =
                process_for lbl idoml at_ids 0 1 ndims 0 [(body, [], [])] ccode kloc
                in
            let _ = new_for_block_ctx ndims flags nested_status par_status kloc in
            let body_ccode = if is_parallel_for then decl_nested_status else [] in
            (* inside the loop body context form `<etyp> v=e` expressions (or more complex ones in the case of complex types) *)
            let body_ccode = decl_for_body_elems body_elems body_ccode in
            (* add the loop body itself *)
            let (_, body_ccode) = kexp2cexp body (ref None) body_ccode in
            let body_loc = get_kexp_loc body in
            (* add the initialization and the cleanup sections, if needed *)
            let (br_label, body_stmt) = finalize_loop_body body_ccode true body_loc in

            (* form (possibly nested) for statement *)
            let (_, for_stmt) = List.fold_left (fun (k, for_stmt) (t_opt, for_inits, for_check_opt, for_incrs) ->
                let for_stmt = CStmtFor(t_opt, for_inits, for_check_opt, for_incrs, for_stmt, kloc) in
                (k+1, (if k > 0 || pre_body_ccode = [] then for_stmt else
                    rccode2stmt (for_stmt :: pre_body_ccode) for_loc))) (0, body_stmt) (List.rev for_headers)
                in
            (* add the non-local "break" label if needed *)
            let post_ccode = if br_label = noid then post_ccode else (CStmtLabel(br_label, end_for_loc)) :: post_ccode in
            let (omp_pragma, post_ccode) = if not is_parallel_for then ([], post_ccode) else
                ([CMacroPragma ("omp parallel for", kloc)],
                (add_fx_call par_status post_ccode kloc)) in
            (* add it all to ccode; nothing to return/assign, since "for-loop" is "void" expression *)
            (false, dummy_exp, (post_ccode @ [for_stmt] @ omp_pragma @ ccode))
        | KExpWhile(c, body, _) ->
            let _ = new_block_ctx BlockKind_Loop kloc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] in
            let (is_for_loop, check_code) =
                (match (cc, cc_code) with
                | (CExpLit((LitBool true), _), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = make_break_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code))
                in
            let (_, body_ccode) = kexp2cexp body (ref None) [] in
            let body_ccode = body_ccode @ check_code in
            let (_, body_stmt) = finalize_loop_body body_ccode true kloc in
            let loop_stmt = (if is_for_loop then
                    CStmtFor(None, [], None, [], body_stmt, kloc)
                else
                    CStmtWhile(cc, body_stmt, kloc))
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpDoWhile(body, c, _) ->
            let _ = new_block_ctx BlockKind_Loop kloc in
            let (_, body_ccode) = kexp2cexp body (ref None) [] in
            let (cc, cc_code) = kexp2cexp c (ref None) [] in
            let (is_for_loop, check_code) =
                (match (cc, cc_code) with
                | (CExpLit((LitBool true), _), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = make_break_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code))
                in
            let body_ccode = check_code @ body_ccode in
            let (_, body_stmt) = finalize_loop_body body_ccode true kloc in
            let loop_stmt = if is_for_loop then
                    CStmtFor(None, [], None, [], body_stmt, kloc)
                else
                    CStmtDoWhile(body_stmt, cc, kloc)
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpCCode(ccode_str, _) ->
            if (curr_block_ctx kloc).bctx_kind <> BlockKind_Global then
                raise_compile_err kloc "cgen: unexpected ccode expression"
            else ();
            top_inline_ccode := CExp (CExpCCode(ccode_str, kloc)) :: !top_inline_ccode;
            (false, dummy_exp, ccode)
        | KDefVal(i, e2, _) ->
            let {kv_typ; kv_cname; kv_flags} = get_kval i kloc in
            let _ = if (is_val_global kv_flags) || (get_val_ctor kv_flags) <> noid then
                add_to_defined i else () in
            let {ktp_ptr; ktp_complex; ktp_scalar} = K_annotate_types.get_ktprops kv_typ kloc in
            let ctyp = C_gen_types.ktyp2ctyp kv_typ kloc in
            let bctx = curr_block_ctx kloc in
            let (is_ccode, ccode_lit, ccode_loc) = match e2 with
                | KExpCCode (c, (_, l)) -> (true, c, l)
                | _ -> (false, "", kloc)
                in
            let ctor_id = get_val_ctor kv_flags in
            let is_temp = kv_flags.val_flag_temp in
            let is_temp_ref = kv_flags.val_flag_tempref in
            let is_global = bctx.bctx_kind == BlockKind_Global && not is_temp && not is_temp_ref in
            let is_fast_cons = is_temp && (match e2 with
                | KExpBinOp(OpCons, a, (Atom.Id l), _) when (IdSet.mem l u1vals) ->
                    (match (kinfo_ l kloc) with
                    | KVal {kv_flags} -> kv_flags.val_flag_temp
                    | _ -> false)
                | _ -> false)
                in
            (* there are 3 cases (ce2 denotes e2 converted to C):
                1. definition "ctyp i = ce2" is not added; instead, i is replaced with ce2.
                2. i is defined separately: "ctyp i[={}|0];" and then
                   expression is compiled with 'i' as the destination.
                3. i is defined and initialized at once: "ctyp i=ce2;"
            *)
            let ccode =
                if is_ccode then
                    let (_, delta_ccode) = create_cdefval i ctyp kv_flags "" (Some (CExpCCode(ccode_lit, ccode_loc))) [] kloc in
                    let _ = bctx.bctx_prologue <- delta_ccode @ bctx.bctx_prologue in
                    ccode
                else if ctor_id <> noid then
                    let tag_exp = make_id_t_exp ctor_id CTypCInt kloc in
                    let is_null = (match kv_typ with
                        | KTypName tn -> (match (kinfo_ tn kloc) with
                            | KVariant {contents={kvar_flags}} -> kvar_flags.var_flag_recursive && kvar_flags.var_flag_opt
                            | _ -> false)
                        | _ -> false)
                        in
                    let (init_exp, delta_ccode) =
                        if not ktp_ptr then
                            let init_exp = CExpInit([tag_exp], (ctyp, kloc)) in
                            (init_exp, [])
                        else if is_null then
                            ((make_nullptr kloc), [])
                        else
                            (* temporarily put (i, ctyp) into the value table *)
                            let (i_exp, _) = create_cdefval i ctyp (default_val_flags()) "" None [] kloc in
                            let (rn, _, _, _) = get_struct i_exp in
                            let struct_ctyp = CTypName rn in
                            let data_id = gen_temp_idc ((pp_id2str i) ^ "_data") in
                            let rc_exp = make_int_exp 1 kloc in
                            let data_init = CExpInit([rc_exp; tag_exp], (struct_ctyp, kloc)) in
                            let (data_exp, delta_ccode) = create_cdefval data_id struct_ctyp
                                {(default_val_flags()) with val_flag_private=true} ""
                                (Some data_init) [] kloc in
                            ((cexp_get_addr data_exp), delta_ccode)
                        in
                    let (_, delta_ccode) = create_cdefval i ctyp
                        {(default_val_flags()) with val_flag_global=mod_sc}
                        "" (Some init_exp) delta_ccode kloc in
                    (* just put initialization into the global scope, no destructors are needed *)
                    let _ = bctx.bctx_prologue <- delta_ccode @ bctx.bctx_prologue in
                    ccode
                else if is_fast_cons || ((is_temp_ref || (ktp_scalar && is_temp)) && (IdSet.mem i u1vals)) then
                    let (ce2, ccode) = kexp2cexp e2 (ref None) ccode in
                    (* we still need to declare i to be able to access its type *)
                    let _ = create_cdefval i ctyp kv_flags "" None [] kloc in
                    let _ = i2e := Env.add i ce2 !i2e in
                    ccode
                else if is_temp_ref then
                    let (ce2, ccode) = kexp2cexp e2 (ref None) ccode in
                    let (_, ccode) = add_local_tempref i ctyp kv_flags ce2 ccode kloc in
                    ccode
                else if ktp_complex || is_global ||
                    (match e2 with
                    | KExpAtom _ | KExpBinOp _ | KExpUnOp _ | KExpIntrin _ | KExpMkTuple _
                    | KExpMkRecord _ | KExpAt _ | KExpMem _ | KExpCast _ | KExpCCode _ -> false
                    | _ -> true) then
                    (* disable i=e2 assignment if i has complex type and e2 is "Nil".
                       If i is complex, it will be initialized anyway with "0" or "{}".
                       We do not need to re-initialize it once again *)
                    let saved_cleanup = bctx.bctx_cleanup in
                    let _ = bctx.bctx_cleanup <- [] in
                    let assign_e2 =
                        match (ktp_complex, e2) with
                        | (true, KExpAtom((Atom.Lit LitNil), _)) -> false
                        | _ -> true
                        in
                    let (flags, e0_opt, assign_e2) =
                        if not is_global then (kv_flags, None, assign_e2)
                        else
                            (* if a global value/variable is initialized with constant,
                            we just use this constant for its initialization instead of
                            setting it to "0" and reassigning inside fx_init() *)
                            let (e0_opt, assign_e2) =
                            if ktp_complex then
                                (None, assign_e2)
                            else if ktp_ptr || ktp_scalar then
                                (match e2 with
                                | KExpAtom((Atom.Lit l), (e2_ktyp, e2_loc)) ->
                                    let e2_ctyp = C_gen_types.ktyp2ctyp e2_ktyp e2_loc in
                                    (Some (CExpLit(l, (e2_ctyp, e2_loc))), false)
                                | _ -> (None, assign_e2))
                            else
                                (None, assign_e2)
                            in
                        (kv_flags, e0_opt, assign_e2)
                        in
                    let (i_exp, delta_ccode) = add_local i ctyp flags e0_opt [] kloc in
                    let ccode = if is_global then (bctx.bctx_prologue <- delta_ccode @ bctx.bctx_prologue; ccode)
                        else delta_ccode @ ccode in
                    if is_global then
                        (module_cleanup := bctx.bctx_cleanup @ !module_cleanup;
                        bctx.bctx_cleanup <- saved_cleanup)
                    else
                        bctx.bctx_cleanup <- bctx.bctx_cleanup @ saved_cleanup;
                    if assign_e2 then
                        let (_, ccode) = kexp2cexp e2 (ref (Some i_exp)) ccode in
                        (match ccode with
                        | CExp (CExpBinOp(COpAssign, CExpIdent(j, _), e, (_, loc))) ::
                            CDefVal(t, i, None, _) :: rest when j = i ->
                            CDefVal(t, i, (Some e), loc) :: rest
                        | _ -> ccode)
                    else
                        ccode
                else
                    let (ce2, ccode) = match (ktp_ptr, e2) with
                        | (false, KExpAtom((Atom.Lit LitNil), (_, loc))) -> (CExpInit([], (ctyp, loc)), ccode)
                        | _ -> kexp2cexp e2 (ref None) ccode
                        in
                    let (_, ccode) = match (e2, ccode) with
                        | ((KExpMkRecord _), (CDefVal (t, tval, (Some rhs), loc) :: rest))
                        | ((KExpMkTuple _), (CDefVal (t, tval, (Some rhs), loc) :: rest)) ->
                            add_local i ctyp kv_flags (Some rhs) rest kloc
                        | _ -> add_local i ctyp kv_flags (Some ce2) ccode kloc
                        in
                    ccode
                in
            (if kv_cname = "" then () else
            match (cinfo_ i kloc) with
            | CVal cv ->
                let cv = {cv with cv_cname=kv_cname} in
                set_idc_entry i (CVal cv)
            | _ -> ());
            (false, dummy_exp, ccode)
        | KDefFun kf ->
            (*
                generate new context.
                generate ccode for the body with dstid=fx_result.
                add the prologue and the cleanup sections to the generated c code.
                before cleanup possibly insert a label if needed.
                prior to the cleanup save the output expression if needed
                (because it may use elements that will be released)
                after cleanup section add "return fx_status;" if needed or
                "return ret_exp"; if the function is nothrow and is not void.

                handle the case of 'c code'-body separately
            *)
            let {kf_name; kf_rt; kf_closure; kf_body; kf_cname; kf_flags; kf_loc} = !kf in
            let {kci_arg; kci_fcv_t} = kf_closure in
            let ctor = get_fun_ctor kf_flags in
            let _ = if kci_arg = noid then () else ensure_sym_is_defined_or_declared kf_name kf_loc in
            let _ = add_to_defined kf_name in
            let _ = new_block_ctx (BlockKind_Fun kf_name) kloc in
            let (args, rt, is_nothrow, cf) = match (cinfo_ kf_name kf_loc) with
                | CFun ({contents={cf_args; cf_flags; cf_rt}} as cf) ->
                    let is_nothrow = cf_flags.fun_flag_nothrow in
                    (cf_args, cf_rt, is_nothrow, cf)
                | _ -> raise_compile_err kf_loc (sprintf "cgen: the function '%s' declaration was not properly converted" (idk2str kf_name kf_loc))
                in
            let (real_args, retid, _, _) = unpack_fun_args args rt is_nothrow in
            let nreal_args = List.length real_args in
            (* in the list of parameters the return value (if any) can be the last one
               (in the case of no-throw functions) or pre-last one
               (in the case of functions that may throw exceptions)
            *)
            let new_body = (match (kf_body, ctor) with
                (* C function *)
                | (KExpCCode(code, (_, loc)), CtorNone) -> CExp (CExpCCode(code, loc)) :: []
                (* generic function *)
                | (_, CtorNone) ->
                    let dstexp_r = ref (if retid = noid then None else
                        (Some (cexp_deref (make_id_exp retid kf_loc))))
                        in
                    let orig_status_id = gen_temp_idc "fx_status" in
                    let (status_exp, ccode) = create_cdefval orig_status_id CTypCInt
                        (default_var_flags()) "fx_status"
                        (Some (make_int_exp 0 kf_loc)) [] kf_loc in
                    let status_id = if is_nothrow then noid else orig_status_id in
                    let ccode = if status_id = noid || not kf_flags.fun_flag_recursive then ccode else
                        let call_chkstk = make_call (get_id "fx_check_stack") [] CTypCInt kf_loc in
                        add_fx_call call_chkstk ccode kf_loc
                        in
                    (*let _ = printf "converting function %s:\n" kf_cname in*)
                    let _ = List.iter (fun (a, t, flags) ->
                        if not (List.mem CArgPassByPtr flags) then () else
                            i2e := Env.add a (cexp_deref (make_id_exp a kf_loc)) !i2e) real_args
                        in
                    let ccode = if kci_arg = noid then ccode else
                        let fcv_ptr_ctyp = make_ptr (CTypName kci_fcv_t) in
                        let fcv_arg_exp0 = make_id_t_exp (get_id "fx_fv") std_CTypVoidPtr kf_loc in
                        let cast_ptr = CExpCast(fcv_arg_exp0, fcv_ptr_ctyp, kf_loc) in
                        let (_, ccode) = create_cdefval kci_arg fcv_ptr_ctyp (default_val_flags()) ""
                            (Some cast_ptr) ccode kf_loc in
                        ccode
                        in
                    let (ret_e, ccode) = kexp2cexp kf_body dstexp_r ccode in
                    let end_loc = get_kexp_end kf_body in
                    let bctx = curr_block_ctx end_loc in
                    (* exclude FX_CHECK_EXN() if it's in the very end of function *)
                    let ccode = match ccode with
                        | CExp (CExpCall(CExpIdent (f, _), _, _)) :: rest when f = !std_FX_CHECK_EXN ->
                            bctx.bctx_label_used <- bctx.bctx_label_used - 1; rest
                        | _ -> ccode
                        in
                    let {bctx_label; bctx_prologue; bctx_cleanup; bctx_label_used} = bctx in
                    let ccode = if bctx_label_used > 0 then
                        CStmtLabel(bctx_label, end_loc) :: ccode else ccode in
                    let (ret_e, ccode) =
                        if bctx_cleanup = [] then
                            (ret_e, ccode)
                        else
                            let (ret_e, ccode) =
                                if retid <> noid || status_id <> noid || (Utils.is_some !dstexp_r) then
                                    (ret_e, ccode)
                                else
                                    (match ret_e with
                                    | CExpInit([], _) | CExpLit _ | CExpIdent _ -> (ret_e, ccode)
                                    | _ ->
                                        create_cdefval (gen_temp_idc "result") (get_cexp_typ ret_e)
                                            (default_val_flags()) "" (Some ret_e) ccode end_loc)
                            in
                                (ret_e, (bctx_cleanup @ ccode))
                        in
                    let ccode = if status_id <> noid then
                            CStmtReturn ((Some status_exp), end_loc) :: ccode
                        else if rt = CTypVoid then ccode
                        else CStmtReturn ((Some ret_e), end_loc) :: ccode
                        in
                    (List.rev bctx_prologue) @ (List.rev ccode)
                (* recursive or non-recursive variant constructor *)
                | (_, CtorVariant(tag_value)) ->
                    let (have_tag, is_recursive_variant) = match kf_rt with
                        | KTypName vn ->
                            (match (kinfo_ vn kf_loc) with
                            | KVariant {contents={kvar_flags}} ->
                                let have_tag = kvar_flags.var_flag_have_tag in
                                let is_recursive = kvar_flags.var_flag_recursive in
                                (have_tag, is_recursive)
                            | _ -> raise_compile_err kf_loc
                                (sprintf "cgen: the return type of variant constructor %s is not variant" (id2str kf_name)))
                        | _ -> raise_compile_err kf_loc
                            (sprintf "cgen: the return type of variant constructor %s is not variant" (id2str kf_name))
                        in
                    let var_exp = (make_id_exp retid kf_loc) in
                    let result_ctyp = C_gen_types.ktyp2ctyp kf_rt kf_loc in
                    let (var_exp, ccode, ret_ccode) =
                        if is_recursive_variant then
                            let alloc_var = make_call !std_FX_MAKE_RECURSIVE_VARIANT_IMPL_START
                                [CExpTyp(result_ctyp, kf_loc)] CTypVoid kf_loc in
                            let (var_exp, _) = create_cdefval (gen_temp_idc "v") result_ctyp
                                    (default_var_flags()) "v" None [] kf_loc in
                            let ret_ccode = [CStmtReturn (Some (make_int_exp 0 kf_loc), kf_loc)] in
                            (var_exp, [CExp alloc_var], ret_ccode)
                        else
                            (var_exp, [], [])
                        in
                    let init_tag = make_assign (cexp_arrow var_exp (get_id "tag") CTypInt)
                        (make_id_t_exp tag_value CTypCInt kloc) in
                    let ccode = if have_tag then (CExp init_tag) :: ccode else ccode in
                    let dst_base = cexp_arrow var_exp (get_id "u") CTypAny in
                    let dst_base = cexp_mem dst_base (get_orig_id kf_name) CTypAny in
                    let (_, ccode) = List.fold_left (fun (idx, ccode) (a, t, flags) ->
                        let src_exp = make_id_t_exp a t kf_loc in
                        let (src_exp, t) = maybe_deref_fun_arg idx src_exp t flags kf_loc in
                        let dst_exp = dst_base in
                        let dst_exp = if nreal_args = 1 then dst_exp else
                            let tup_elem = get_id ("t" ^ (string_of_int idx)) in
                            (cexp_mem dst_exp tup_elem t)
                            in
                        let ccode = C_gen_types.gen_copy_code src_exp dst_exp t ccode kf_loc in
                        (idx+1, ccode)) (0, ccode) real_args
                    in
                    List.rev (ret_ccode @ ccode)
                (* function pointer/closure constructor *)
                | (_, CtorFP(f_id)) ->
                    let fcv_t_id = match (kinfo_ f_id kf_loc) with
                        | KFun {contents={kf_closure={kci_fcv_t}}} -> kci_fcv_t
                        | _ -> raise_compile_err kf_loc
                            (sprintf "cgen: '%s' is not a function" (get_idk_cname f_id kf_loc))
                        in
                    let fcv_t = CTypName fcv_t_id in
                    let free_f_exp = match (C_gen_types.get_free_f fcv_t true false kf_loc) with
                        | (_, (Some free_f)) -> free_f
                        | _ -> raise_compile_err kf_loc
                            (sprintf "cgen: missing destructor for closure vars '%s'"
                            (get_idk_cname fcv_t_id kf_loc))
                        in
                    let alloc_fcv = make_call !std_FX_MAKE_FP_IMPL_START
                        [CExpTyp(fcv_t, kf_loc); free_f_exp;
                        make_id_t_exp f_id std_CTypVoidPtr kloc] CTypVoid kf_loc
                        in
                    let (fcv_exp, _) = create_cdefval (gen_temp_idc "fcv") (make_ptr fcv_t)
                        (default_val_flags()) "fcv" None [] kf_loc in
                    let ret_ccode = [CStmtReturn (Some (make_int_exp 0 kf_loc), kf_loc)] in
                    let ccode = [CExp alloc_fcv] in
                    let (_, ccode) = List.fold_left (fun (idx, ccode) (a, t, flags) ->
                        let src_exp = make_id_t_exp a t kf_loc in
                        let (src_exp, t) = maybe_deref_fun_arg idx src_exp t flags kf_loc in
                        let fcv_elem = get_id ("t" ^ (string_of_int idx)) in
                        let dst_exp = (cexp_arrow fcv_exp fcv_elem t) in
                        let ccode = C_gen_types.gen_copy_code src_exp dst_exp t ccode kf_loc in
                        (idx+1, ccode)) (0, ccode) real_args
                    in
                    List.rev (ret_ccode @ ccode)
                | (_, CtorExn(exn_id)) ->
                    let (exn_typ, exn_tag, exn_std, exn_data_id, exn_info) = match (cinfo_ exn_id kf_loc) with
                        | CExn {contents={cexn_typ; cexn_tag; cexn_std; cexn_data; cexn_info}} ->
                            (cexn_typ, cexn_tag, cexn_std, cexn_data, cexn_info)
                        | _ -> raise_compile_err kf_loc (sprintf
                            "cgen: constructor of exception '%s' is expecting converted KExn=>CExn structure"
                            (idk2str exn_id kf_loc))
                        in
                    if exn_std then
                        ccode
                    else
                        let exn_data_t = CTypName(exn_data_id) in
                        let alloc_exn_data = make_call !std_FX_MAKE_EXN_IMPL_START
                            [(make_id_t_exp exn_tag CTypCInt kf_loc);
                            CExpTyp(exn_data_t, kf_loc);
                            (make_id_t_exp exn_info !std_fx_exn_info_t kf_loc)]
                            CTypVoid kf_loc
                            in
                        let ret_ccode = [CStmtReturn (Some (make_int_exp 0 kf_loc), kf_loc)] in
                        let exn_data = make_id_t_exp (get_id "exn_data") (make_ptr exn_data_t) kf_loc in
                        let dst_exp = cexp_arrow exn_data (get_id "data") exn_typ in
                        let ccode = [CExp alloc_exn_data] in
                        let (_, ccode) = List.fold_left (fun (idx, ccode) (a, t, flags) ->
                            let src_exp = make_id_t_exp a t kf_loc in
                            let (src_exp, t) = maybe_deref_fun_arg idx src_exp t flags kf_loc in
                            let dst_exp = if nreal_args = 1 then dst_exp else
                                let t_elem = get_id ("t" ^ (string_of_int idx)) in
                                (cexp_mem dst_exp t_elem t)
                                in
                            let ccode = C_gen_types.gen_copy_code src_exp dst_exp t ccode kf_loc in
                            (idx+1, ccode)) (0, ccode) real_args
                        in
                        List.rev (ret_ccode @ ccode)
                | _ -> raise_compile_err kloc (sprintf "cgen: unsupported type of constructor %s: %s"
                        kf_cname (ctor2str ctor)))
                in
            pop_block_ctx kloc;
            cf := {!cf with cf_body = (filter_out_nops new_body)};
            (false, dummy_exp, ccode)
        | KDefExn ke -> (* handled in c_gen_fdecls *)
            (false, dummy_exp, ccode)
        | KDefVariant kvar -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefTyp kt -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefClosureVars kcv -> (false, dummy_exp, ccode) (* handled in c_gen_fdecls *)
        in
        if not assign || ctyp = CTypVoid then
            (result_exp, ccode)
        else match !dstexp_r with
        | Some (dst_exp) ->
            let skip_copy = (match result_exp with
            | CExpLit(LitNil, _) ->
                let {ctp_ptr} = C_gen_types.get_ctprops ctyp kloc in ctp_ptr
            | _ -> false) in
            let ccode = if skip_copy then ccode else
                C_gen_types.gen_copy_code result_exp dst_exp ctyp ccode kloc
            in
            (dst_exp, ccode)
        | _ -> (result_exp, ccode)
    in
    (* ok, here is the top-level C code generation procedure *)

    (* 1. convert all types to C *)
    (*let c_types_ccode = C_gen_types.convert_all_typs top_code in*)

    (* 2. convert function declarations to C *)
    (*let (c_fdecls, mod_init_calls) = C_gen_fdecls.convert_all_fdecls top_code in*)
    (*let _ = C_pp.pprint_top (c_types_ccode @ c_fdecls) in*)

    (* 3. all the global code should be put into fx_init_...() function. Let's form its body,
          starting with the classical `int fx_status = 0;` *)
    let start_loc = if top_code = [] then noloc else get_kexp_loc(List.hd top_code) in
    let _ = new_block_ctx BlockKind_Global start_loc in
    let (status_exp, ccode) = create_cdefval (gen_temp_idc "fx_status") CTypCInt
        (default_var_flags()) "fx_status" (Some (make_int_exp 0 start_loc)) [] start_loc in
    (* 4. convert all the code to C. It will automatically update functions bodies *)
    let (e, ccode) = kexp2cexp (code2kexp top_code start_loc) (ref None) ccode in
    (*let e = make_dummy_exp start_loc in*)
    let end_loc = get_cexp_loc e in

    (* 5. bctx_prologue will contain all the global definitions.
          bctx_cleanup will contain destructor calls for all the global definitions.
          Need to add it to end of fx_deinit_...() and
          form its body
    *)
    let {bctx_prologue; bctx_label; bctx_cleanup; bctx_label_used} = curr_block_ctx end_loc in
    let (global_vars, temp_init_vals) = List.fold_left (fun (global_vars, temp_init_vals) s ->
        let is_global = match s with
            | CDefVal (_, i, _, loc) ->
                (match (cinfo_ i loc) with
                | CVal {cv_flags} -> not (cv_flags.val_flag_temp || cv_flags.val_flag_tempref)
                | _ -> true)
            | _ -> true
            in
        if is_global then
            (s :: global_vars, temp_init_vals)
        else
            (global_vars, s :: temp_init_vals))
        ([], []) bctx_prologue in
    let _ = pop_block_ctx end_loc in
    let ccode =
        match e with
        | CExpIdent _ | CExpLit _ -> ccode
        | _ -> (cexp2stmt e) :: ccode
        in
    let ccode = if bctx_label_used = 0 then ccode else (CStmtLabel(bctx_label, end_loc)) :: ccode in
    let ccode = filter_out_nops ccode in
    let (ccode, deinit_ccode) = ((bctx_cleanup @ ccode), !module_cleanup) in
    let ccode = CStmtReturn ((Some status_exp), end_loc) :: ccode in
    let init_cname = "fx_init_" ^ km_cname in
    let init_name = (gen_temp_idc init_cname) in
    let init_f = ref {cf_name=init_name; cf_args=[]; cf_rt=CTypCInt;
        cf_cname=init_cname; cf_body=temp_init_vals @ mod_init_calls @ (List.rev ccode);
        cf_flags=default_fun_flags(); cf_scope=ScGlobal::[]; cf_loc=end_loc} in
    let deinit_cname = "fx_deinit_" ^ km_cname in
    let deinit_name = (gen_temp_idc deinit_cname) in
    let deinit_f = ref {cf_name=deinit_name; cf_args=[]; cf_rt=CTypVoid;
        cf_cname=deinit_cname; cf_body=(List.rev deinit_ccode);
        cf_flags=default_fun_flags(); cf_scope=ScGlobal::[]; cf_loc=end_loc} in
    let _ = set_idc_entry init_name (CFun init_f) in
    let _ = set_idc_entry deinit_name (CFun deinit_f) in
    let mod_names = if km_main then km_cname :: (List.map (fun {cmod_cname} -> cmod_cname) cmods) else [] in
    let all_ccode_prologue = (gen_ccode_prologue km_main start_loc) @ (List.rev !top_inline_ccode) in
    let all_ccode = global_vars @ (List.rev !fwd_fdecls) @ c_fdecls @
        [CDefFun init_f; CDefFun deinit_f] @ (gen_main km_main mod_names end_loc) in
    (all_ccode_prologue, all_ccode)

let gen_ccode_all kmods =
    (* ok, here is the top-level C code generation procedure *)

    (* 1. convert all types to C from all modules *)
    let (all_ctypes_fwd_decl, all_ctypes_decl, all_ctypes_fun_decl) = C_gen_types.convert_all_typs kmods in

    (* 2. convert function declarations to C *)
    let (kmods_plus, _) = List.fold_left (fun (kmods_plus, all_exn_data_decls) km ->
        let (c_fdecls, mod_init_calls, mod_exn_data_decls) = C_gen_fdecls.convert_all_fdecls km.km_top in
        (((km, c_fdecls, mod_init_calls, (List.rev all_exn_data_decls)) :: kmods_plus),
        ((List.rev mod_exn_data_decls) @ all_exn_data_decls))) ([], []) kmods in

    (* 3. convert each module to C *)
    let cmods = List.fold_left (fun cmods (km, c_fdecls, mod_init_calls, exn_data_decls) ->
        let {km_name; km_cname; km_top; km_main; km_pragmas} = km in
        let (prologue, ccode) = gen_ccode cmods km c_fdecls mod_init_calls in
        let ctypes = C_gen_types.elim_unused_ctypes km.km_name all_ctypes_fwd_decl
            (all_ctypes_decl @ exn_data_decls) all_ctypes_fun_decl ccode in
        (*let _ = printf "'%s' pragmas: c++=%B; libs=[%s]\n" (pp_id2str km_name) km_pragmas.pragma_cpp
            (String.concat ";" (List.map (fun (s, _) -> s) km_pragmas.pragma_clibs)) in*)
        { cmod_name=km_name; cmod_cname=km_cname; cmod_ccode=prologue @ ctypes @ ccode;
          cmod_main=km_main; cmod_recompile=true; cmod_pragmas=km_pragmas } :: cmods)
        [] (List.rev kmods_plus)
    in
    List.rev cmods
