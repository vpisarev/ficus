(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Full-scale lambda lifting.
    Unlike k_simple_ll, this algorithm
    moves all the functions to the top level.

    Also, unlike k_simple_ll, this algorithm is executed after all
    other K-form optimizations, including dead code elimination,
    tail-recursive call elimination, inline expansion etc.
    (But dead code elimination runs once again after it to remove
    some of the generated by this step structures and functions that are not used)

    In order to move all the functions to the top level and preserve
    semantics of the original code, we need to transform some nested functions,
    as well as some outer code that uses those functions.

    * We analyze each function and see if the function has 'free variables',
      i.e. variables that are non-local and yet are non-global.
    a) If the function has some 'free variables',
      it needs a special satellite structure called 'closure data'
      that incapsulates all the free variables. The function itself
      is transformed, it gets an extra parameter, which is pointer to the
      closure data (this is done at C code generation step actually).
      All the accesses to free variables are replaced
      with the closure data access operations. Then, when the function
      occurs in code (if it does not occur, it's eliminated as dead code),
      a 'closure' is created, which is a pair (function, (closure_data or 'nil')).
      This pair is used instead of the original function. Here is the example:

      fun foo(n: int) {
        fun bar(m: int) = m * n
        bar
      }

      is replaced with

      fun bar(m: int, c: bar_closure_t) {
        m * c->n
      }
      fun foo(n: int) {
        make_closure(bar, bar_closure_t {n})
      }

    b) If the function does not have any 'free variables', we may still
      need a closure, i.e. we may need to represent this function as a pair,
      because in general when we pass a function as parameter to another function
      or store it as a value (essentially, we store a function pointer), the caller
      of that function does not know whether it needs free variables or not, so
      we need a consistent representation of functions that are called indirectly.
      But in this case we can have a pair ('some function', nil), i.e. we just use something like
      NULL pointer instead of a pointer to real closure. So, the following code:

      fun foo(n: int) {
        fun bar(m: int) = m*n
        fun baz(m: int) = m+1
        if (generate_random_number() % 2 == 0) bar else baz
      }
      val transform_f = foo(5)
      for (i <- 0:10) println(transform_f(i))

      is transformed to:

      fun bar( m: int, c: bar_closure_t* ) = m*c->n
      fun baz( m: int, _: nil_closure_t* ) = m+1

      fun foo(n: int) =
        if (generate_random_number() % 2 == 0)
          make_closure(bar, bar_closure_t {n})
        else
          make_closure(baz, nil)

      val (transform_f_ptr, transform_f_fvars) = foo(5)
      for (i <- 0:10) println(transform_f_ptr(i, transform_f_fvars))

      However, in the case (b) when we call the function directly, e.g.
      we call 'baz' as 'baz', not via 'transform_f' pointer, we can
      avoid the closure creation step and just call it as 'baz(real_arg, nil)'.

    From the above description it may seem that the algorithm is very simple,
    but there are some nuances:

    1. the nested function with free variables may not just read some values
      declared outside, it may modify mutable values, i.e. var's.
      Or, it may read from a 'var', and yet it may call another nested function
      that may access the same 'var' and modify it. We could have stored an address
      of each var in the closure data, but that would be unsafe, because we may
      return the created closure outside of the function
      (which is a typical functional language pattern for generators, see below)
      where 'var' does not exist anymore. The robust solution for this problem is
      to convert each 'var', which is used at least once as a free variable,
      into a reference:

      fun create_inc(start: int) {
          var v = start
          fun inc_me() {
            val temp = v; v += 1; temp
          }
          inc_me
      }

      this is converted to:

      fun inc_me( c: inc_me_closure_t* ) {
          val temp = *c->v; *c->v += 1; temp
      }
      fun create_inc(start: int) {
          val v = ref(start)
          make_closure(inc_me, inc_me_closure_t {v})
      }

    2. besides the free variables, the nested function may also call:
       2a. itself. This is a simple case. We just call it and pass the same closure data
          fun bar( n: int, c: bar_closure_t* ) = if (n <= 1) 1 else { ... bar(n-1, c) }
       2b. another function that needs some free variables from the outer scope
          fun foo(n: int) {
              fun bar(m: int) = baz(m+1)
              fun baz(m: int) = m*n
              (bar, baz)
          }

          in order to form the closure for 'baz', 'bar' needs to read 'n' value, which it does not
          access directly. That is, the code can be converted to:

          // option 1: dynamically created closure
          fun bar( m: int, c:bar_closure_t* ) {
              val (baz_cl_f, baz_cl_fv) = make_closure(baz, baz_closure_t {c->n})
              baz_cl_f(m+1, baz_cl_fv)
          }
          fun baz( m: int, c:baz_closure_t* ) = m*c->n
          fun foo(n: int) = (make_closure(bar, bar_closure_t {n}), make_closure(baz, baz_closure_t {n})

          or it can be converted to

          // option 2: nested closure
          fun bar( m: int, c:bar_closure_t* ) {
              val (baz_cl_f, baz_cl_fv) = c->baz_cl
              baz_cl_f(m+1, baz_cl_fv)
          }
          fun baz( m: int, c:baz_closure_t* ) = m*c->n
          fun foo(n: int) = {
              val baz_cl = make_closure(baz, baz_closure_t {n})
              val bar_cl = make_closure(bar, {baz_cl})
              (bar_cl, baz_cl)
          }

          or it can be converted to

          // option 3: shared closure
          fun bar( m: int, c:foo_nested_closure_t* ) {
              baz(m+1, c)
          }
          fun baz( m: int, c:foo_nested_closure_t* ) = m*c->n
          fun foo(n: int) = {
              val foo_nested_closure_data = foo_nested_closure_t {n}
              val bar_cl = make_closure(bar, foo_nested_closure_data)
              val baz_cl = make_closure(baz, foo_nested_closure_data)
              (bar_cl, baz_cl)
          }

        The third option in this example is the most efficient. But in general it may
        be not very easy to implement, because between bar() and baz() declarations there
        can be some value definitions, i.e. in general baz() may access some values that
        are computed using bar(), and then the properly initialized shared closure may be
        difficult to build.

        The second option is also efficient, because we avoid repetitive call to
        make_closure() inside bar(). However if not only 'bar' calls 'baz',
        but also 'baz' calls 'bar', it means that both closures need to reference each other,
        so we have a reference cycle and this couple of closures
        (or a cluster of closures in more general case) will never be released.

        So, for simplicity, we just implement the first, i.e. the slowest option.
        It's not a big problem though, because:
        * the language makes an active use of dynamic data structures
          (recursive variants, lists, arrays, strings, references ...) anyway,
          and so the memory allocation is used often, but it's tuned to be efficient,
          especially for small memory blocks.
        * when we get to the lambda lifting
          stage, we already have expanded many function calls inline
        * the remaining non-expanded nested functions that do not need
          free variables are called directly without creating a closure
        * when we have some critical hotspots, we can transform the critical functions and
          pass some 'free variables' as parameters in order to eliminate closure creation.
          (normally hotspot functions operate on huge arrays and/or they can be
          transformed into tail-recursive functions, so 'mutually-recursive functions'
          and 'hotspots' are the words that rarely occur in the same sentence).
        [TODO] The option are not mutually exclusive; for example, we can use the third,
        most efficient option in some easy-to-detect partial cases (e.g. when the nested functions
        go sequentially without any non-trivially defined values between them) and use
        the first option everywhere else.

    3. In order to implement the first option (2.2b.1) above we need to create an
      iterative algorithm to compute extended sets of free variables for each function.
      First, we find directly accessed free variables. Then we check which functions
      we call from each function and combine their free variables with the directly
      accessible ones. We continue to do so until all the sets of free variables
      for all the functions are stabilized and do not change on the next iteration.
*)

open Ast
open K_form

type ll_func_info_t = { mutable ll_fvars: IdSet.t; ll_declared_inside: IdSet.t; ll_called_funcs: IdSet.t }
type ll_env_t = ll_func_info_t Env.t
type ll_subst_env_t = (id_t*id_t) Env.t

let make_wrappers_for_nothrow top_code =
    let rec wrapf_atom a loc callb =
        match a with
        | Atom.Id (Id.Name _) -> a
        | Atom.Id n ->
            (match (kinfo_ n loc) with
            | KFun {contents={kf_closure={kci_wrap_f}}} ->
                if kci_wrap_f = noid then a else (Atom.Id kci_wrap_f)
            | _ -> a)
        | _ -> a
    and wrapf_ktyp_ t loc callb = t
    and wrapf_kexp_ e callb =
        match e with
        | KDefFun kf ->
            let {kf_name; kf_args; kf_rt; kf_flags; kf_body; kf_closure; kf_scope; kf_loc } = !kf in
            let new_body = wrapf_kexp_ kf_body callb in
            let _ = kf := {!kf with kf_body=new_body} in
            if not (List.mem FunNoThrow kf_flags) || (is_fun_ctor kf_flags) then e
            else
                (let w_name = gen_idk ((pp_id2str kf_name) ^ "_w") in
                let _ = kf := {!kf with kf_closure={kf_closure with kci_wrap_f=w_name}} in
                let w_flags = List.filter (fun f -> f != FunNoThrow) kf_flags in
                let w_args = List.map (fun (a, t) ->
                    let w_a = dup_idk a in
                    let _ = create_kdefval w_a t [ValArg] None [] kf_scope kf_loc in
                    (w_a, t)) kf_args
                    in
                let w_body = KExpCall(kf_name, (List.map (fun (i, _) -> Atom.Id i) w_args), (kf_rt, kf_loc)) in
                let code = create_kdeffun w_name w_args kf_rt w_flags (Some w_body) [e] kf_scope kf_loc in
                rcode2kexp code kf_loc)
        | KExpCall(f, args, (t, loc)) ->
            let args = List.map (fun a -> wrapf_atom a loc callb) args in
            (* leave 'f' as-is: do not transform direct calls (except for the args) *)
            KExpCall(f, args, (t, loc))
        | _ -> walk_kexp e callb
    in
    let callb =
    {
        kcb_typ=Some(wrapf_ktyp_);
        kcb_exp=Some(wrapf_kexp_);
        kcb_atom=Some(wrapf_atom)
    }
    in
    let top_kexp = code2kexp top_code noloc in
    (* do 2 passes to cover both forward and backward references *)
    let top_kexp = wrapf_kexp_ top_kexp callb in
    let top_kexp = wrapf_kexp_ top_kexp callb in
    kexp2code top_kexp

let lift_all top_code =
    let globals = ref (K_simple_ll.find_globals top_code IdSet.empty) in
    let is_global n = IdSet.mem n !globals in
    let ll_env = ref (Env.empty : ll_env_t) in
    let orig_subst_env = ref (Env.empty: ll_subst_env_t) in

    let fold_fv0_ktyp_ t loc callb = () in
    let fold_fv0_kexp_ e callb =
        fold_kexp e callb; (* process all the sub-expressions in any case *)
        match e with
        (* some extra processing for each function *)
        | KDefFun {contents={kf_name; kf_loc}} ->
            let (uv, dv) = used_decl_by_kexp e in
            (* from the set of free variables we exclude global functions, values and types
               because they do not have to be put into a closure anyway *)
            let fv0 = IdSet.diff (IdSet.diff uv dv) !globals in
            let called_funcs = IdSet.fold (fun n called_funcs ->
                match (kinfo_ n kf_loc) with
                | KFun _ ->
                    if (is_global n) then called_funcs
                    else IdSet.add n called_funcs
                | _ -> called_funcs) uv IdSet.empty in
            let fv0 = IdSet.filter (fun fv -> match (kinfo_ fv kf_loc) with
                | KVal _ -> true
                | _ -> false) fv0 in
            ll_env := Env.add kf_name {ll_fvars=fv0; ll_declared_inside=dv; ll_called_funcs=called_funcs} !ll_env
        | _ -> ()
    in let fv0_callb =
    {
        kcb_fold_atom = None;
        kcb_fold_ktyp = Some(fold_fv0_ktyp_);
        kcb_fold_kexp = Some(fold_fv0_kexp_);
        kcb_fold_result = 0
    } in
    (* for each function, top-level or not, find the initial set of free variables,
       as well as the set of called functions *)
    let _ = List.iter (fun e -> fold_fv0_kexp_ e fv0_callb) top_code in

    (* now expand those sets. recursively add to the list of free variables
       all the free variables from the called functions
       (but not defined locally) *)
    let rec finalize_sets iters ll_all =
        let visited_funcs = ref IdSet.empty in
        let changed = ref false in
        let _ = if iters > 0 then () else raise_compile_err noloc
            "finalization of the free var sets takes too much iterations" in
        let rec update_fvars f =
            match (Env.find_opt f !ll_env) with
            | Some ll_info ->
                let { ll_fvars; ll_declared_inside; ll_called_funcs } = ll_info in
                if IdSet.mem f !visited_funcs then ll_fvars
                else
                    let _ = visited_funcs := IdSet.add f !visited_funcs in
                    let size0 = IdSet.cardinal ll_fvars in
                    let fvars = IdSet.fold (fun called_f fvars ->
                        let called_fvars = update_fvars called_f in
                        IdSet.union fvars called_fvars) ll_called_funcs ll_fvars in
                    let fvars = IdSet.diff fvars ll_declared_inside in
                    let size1 = IdSet.cardinal fvars in
                    let _ = if size1 = size0 then () else
                        (ll_info.ll_fvars <- fvars; changed := true) in
                    fvars
            | _ -> IdSet.empty
        in List.iter (fun f -> ignore (update_fvars f)) ll_all;
        if not !changed then (iters-1) else finalize_sets (iters - 1) (List.rev ll_all)
    in let iters0 = 10 in
    let _ = finalize_sets iters0 (List.rev (Env.fold (fun f _ ll_all -> f :: ll_all) !ll_env [])) in
    let all_fvars = Env.fold (fun _ ll_info all_fvars ->
        IdSet.union (ll_info.ll_fvars) all_fvars) !ll_env IdSet.empty in
    let all_mut_fvars = IdSet.filter (fun i -> is_mutable i (get_idk_loc i noloc)) all_fvars in
    (*
      for each mutable variable:
      - convert its type from 't' to 't*' (reference)
      - remove ValMutable flag
    *)
    let _ = IdSet.iter (fun mut_fv ->
        let kv = get_kval mut_fv noloc in
        let { kv_name; kv_typ; kv_flags; kv_scope; kv_loc } = kv in
        let new_kv_name = gen_temp_idk ((pp_id2str kv_name) ^ "_ref") in
        let new_kv_typ = KTypRef(kv_typ) in
        let new_kv_flags = (List.filter (fun f -> f != ValMutable) kv_flags) in
        let new_kv = { kv_name=new_kv_name; kv_cname=""; kv_typ=new_kv_typ; kv_flags=new_kv_flags; kv_scope; kv_loc } in
        let new_old_kv = { kv with kv_flags=ValTempRef::kv_flags } in
        set_idk_entry new_kv_name (KVal new_kv);
        set_idk_entry kv_name (KVal new_old_kv);
        (* in the original function where mutable free var is declared,
           we retain its name in most operations except for KExpMkClosure,
           where the use just created reference *)
        orig_subst_env := Env.add kv_name (kv_name, new_kv_name) !orig_subst_env)
        all_mut_fvars in
    (* iterate through all the functions; for each function with
       free variables define a closure and add an extra parameter *)
    let fold_defcl_ktyp_ t loc callb = () in
    let fold_defcl_kexp_ e callb =
        fold_kexp e callb; (* process all the sub-expressions in any case *)
        match e with
        | KDefFun kf ->
            let {kf_name; kf_args; kf_rt; kf_closure; kf_scope; kf_loc} = !kf in
            (match Env.find_opt kf_name !ll_env with
            | Some ll_info ->
                let fvars = ll_info.ll_fvars in
                if (IdSet.is_empty fvars) then ()
                else
                (let fvar_pairs_to_sort = IdSet.fold (fun fv fvars_to_sort ->
                    ((id2str fv), fv) :: fvars_to_sort) fvars [] in
                let fvar_pairs_sorted = List.sort (fun (a, _) (b, _) -> String.compare a b) fvar_pairs_to_sort in
                let fvars_final = List.map (fun (_, fv) -> fv) fvar_pairs_sorted in
                let fcv_tn = gen_temp_idk ((id2prefix kf_name) ^ "_closure") in
                let (_, make_args, fvars_wt) = List.fold_left (fun (idx, make_args, fvars_wt) fv ->
                    let { kv_name; kv_typ; kv_flags; kv_scope; kv_loc } = get_kval fv kf_loc in
                    let kv_typ = if IdSet.mem fv all_mut_fvars then KTypRef kv_typ else kv_typ in
                    let new_fv = dup_idk fv in
                    let arg = get_id (sprintf "arg%d" idx) in
                    let _ = create_kdefval new_fv kv_typ kv_flags None [] kv_scope kv_loc in
                    (idx+1, (arg :: make_args), ((new_fv, kv_typ) :: fvars_wt))) (0, [], []) fvars_final in
                let fcv_t = ref { kcv_name=fcv_tn; kcv_cname=""; kcv_freevars=(List.rev fvars_wt);
                    kcv_orig_freevars=fvars_final; kcv_scope=kf_scope; kcv_loc=kf_loc } in
                let (_, make_args_ktyps) = Utils.unzip fvars_wt in
                let kf_typ = get_kf_typ kf_args kf_rt in
                let cl_arg = gen_temp_idk "cv" in
                let make_fp = gen_temp_idk "make_fp" in
                let _ = create_kdefconstr make_fp (List.rev make_args_ktyps) kf_typ
                    [FunCtor (CtorFP kf_name)] [] kf_scope kf_loc in
                let _ = create_kdefval cl_arg (KTypName fcv_tn) [] None [] kf_scope kf_loc in
                let new_kf_closure = {kf_closure with kci_arg=cl_arg; kci_fcv_t=fcv_tn; kci_make_fp=make_fp} in
                set_idk_entry fcv_tn (KClosureVars fcv_t);
                kf := { !kf with kf_closure=new_kf_closure })
            | _ -> ())
        | _ -> ()
    in let defcl_callb =
    {
        kcb_fold_atom = None;
        kcb_fold_ktyp = Some(fold_defcl_ktyp_);
        kcb_fold_kexp = Some(fold_defcl_kexp_);
        kcb_fold_result = 0
    } in
    (* recursively process each top-level expression; define the closures etc. *)
    let _ = List.iter (fun e -> fold_defcl_kexp_ e defcl_callb) top_code in

    let defined_so_far = ref IdSet.empty in
    let curr_clo = ref (noid, noid, noid) in
    let curr_top_code = ref ([]: kexp_t list) in
    let curr_subst_env = ref (Env.empty : ll_subst_env_t) in

    let rec walk_atom_n_lift_all_adv a loc get_mkclosure_arg =
        match a with
        | Atom.Id (Id.Name _) -> a
        | Atom.Id n ->
            (match (Env.find_opt n !curr_subst_env) with
            | Some ((nv, nr)) -> if get_mkclosure_arg then (Atom.Id nr) else (Atom.Id nv)
            | _ ->
                (match (kinfo_ n loc) with
                | KFun {contents={kf_flags}} ->
                    if is_fun_ctor kf_flags then ()
                    else raise_compile_err loc
                        (sprintf "for the function '%s' there is no corresponding closure" (id2str n))
                | _ -> ());
                if not get_mkclosure_arg then a
                else
                    (match (Env.find_opt n !orig_subst_env) with
                    | Some ((_, nr)) -> Atom.Id nr
                    | _ -> a))
        | _ -> a
    and walk_atom_n_lift_all a loc callb = walk_atom_n_lift_all_adv a loc false
    and walk_ktyp_n_lift_all t loc callb = t
    and walk_kexp_n_lift_all e callb =
        match e with
        | KDefFun kf ->
            let { kf_name; kf_args; kf_rt; kf_body; kf_closure; kf_scope; kf_loc } = !kf in
            let { kci_arg; kci_fcv_t; kci_make_fp } = kf_closure in
            let saved_dsf = !defined_so_far in
            let saved_clo = !curr_clo in
            let saved_subst_env = !curr_subst_env in
            let _ = curr_clo := (kf_name, kci_arg, kci_fcv_t) in
            let _ = defined_so_far := List.fold_left (fun dsf (arg, _) -> IdSet.add arg dsf) !defined_so_far kf_args in

            let create_defclosure kf code =
                let {kf_name; kf_args; kf_rt; kf_closure={kci_make_fp=make_fp}; kf_scope; kf_loc} = !kf in
                let kf_typ = get_kf_typ kf_args kf_rt in
                let cl_name = dup_idk kf_name in
                let _ = curr_subst_env := Env.add kf_name (cl_name, cl_name) !curr_subst_env in
                let _ = defined_so_far := IdSet.add cl_name !defined_so_far in
                let (_, orig_freevars) = get_closure_freevars kf_name kf_loc in
                let cl_args = List.map (fun fv ->
                    if IdSet.mem fv !defined_so_far then ()
                    else raise_compile_err kf_loc
                        (sprintf "free variable '%s' of '%s' is not defined yet"
                        (id2str fv) (id2str kf_name));
                    walk_atom_n_lift_all_adv (Atom.Id fv) kf_loc true) orig_freevars
                    in
                let make_cl = KExpMkClosure(make_fp, kf_name, cl_args, (kf_typ, kf_loc)) in
                create_kdefval cl_name kf_typ [] (Some make_cl) code kf_scope kf_loc
                in

            let (prologue, def_fcv_t_n_make) =
                if kci_fcv_t = noid then ([], []) else
                    let kcv = match (kinfo_ kci_fcv_t kf_loc) with
                        | KClosureVars kcv -> kcv
                        | _ -> raise_compile_err kf_loc
                            (sprintf "closure type '%s' for '%s' information is not valid (should be KClosureVars ...)"
                            (id2str kci_fcv_t) (id2str kf_name))
                        in
                    let make_kf = match (kinfo_ kci_make_fp kf_loc) with
                        | KFun make_kf -> make_kf
                        | _ -> raise_compile_err kf_loc
                            (sprintf "make_fp '%s' for '%s' information is not valid (should be KClosureVars ...)"
                            (id2str kci_make_fp) (id2str kf_name))
                        in
                    let {kcv_freevars; kcv_orig_freevars} = !kcv in
                    (* for each free variable 'fv' we create a proxy 'val fv_proxy = kf_cl_arg.fv'
                      and add it to the function prologue. We also add the pair (fv, fv_proxy)
                      to the substitution dictionary. That is, we convert all the
                      accesses to the free variables *)
                    let (_, prologue) = List.fold_left2 (fun (idx, prologue) (fv, t) fv_orig ->
                        let _ = if IdSet.mem fv_orig !defined_so_far then () else
                            raise_compile_err kf_loc
                            (sprintf "free variable '%s' of function '%s' is not defined before the function body"
                            (id2str fv_orig) (id2str kf_name)) in
                        let fv_proxy = dup_idk fv in
                        let _ = defined_so_far := IdSet.add fv_proxy !defined_so_far in
                        let (t, kv_flags) = match (kinfo_ fv_orig kf_loc) with
                            | KVal {kv_typ; kv_flags} -> (kv_typ, kv_flags)
                            | _ -> (t, []) in
                        let is_mutable = IdSet.mem fv_orig all_mut_fvars in
                        let kv_flags = List.filter (fun f -> f != ValTempRef && f != ValArg) kv_flags in
                        let (e, prologue, fv_proxy_mkclo_arg) =
                            if not is_mutable then
                                (KExpMem(kci_arg, idx, (t, kf_loc)), prologue, fv_proxy)
                            else
                                let ref_typ = KTypRef t in
                                let fv_ref = gen_idk ((pp_id2str fv) ^ "_ref") in
                                let get_fv = KExpMem(kci_arg, idx, (ref_typ, kf_loc)) in
                                let ref_flags = ValTempRef :: (List.filter (fun f -> f != ValMutable) kv_flags) in
                                let prologue = create_kdefval fv_ref ref_typ ref_flags
                                    (Some get_fv) prologue kf_scope kf_loc in
                                (KExpUnOp(OpDeref, (Atom.Id fv_ref), (t, kf_loc)), prologue, fv_ref)
                            in
                        let _ = curr_subst_env := Env.add fv_orig (fv_proxy, fv_proxy_mkclo_arg) !curr_subst_env in
                        let new_kv_flags = ValTempRef :: kv_flags in
                        let prologue = create_kdefval fv_proxy t new_kv_flags (Some e) prologue kf_scope kf_loc in
                        (idx+1, prologue)) (0, []) kcv_freevars kcv_orig_freevars in
                    (* we also create a closure for each function with free variables
                        that is called from 'kf_name', but is not declared in 'kf_name' *)
                    let prologue = match Env.find_opt kf_name !ll_env with
                        | Some ({ll_declared_inside; ll_called_funcs}) ->
                            let called_fs = IdSet.diff ll_called_funcs ll_declared_inside in
                            IdSet.fold (fun called_f prologue ->
                                match (kinfo_ called_f kf_loc) with
                                | KFun called_kf ->
                                    let {kf_closure={kci_fcv_t=called_fcv_t}} = !called_kf in
                                    if called_fcv_t = noid then prologue
                                    else create_defclosure called_kf prologue
                                | _ -> prologue) called_fs prologue
                        | _ -> raise_compile_err kf_loc
                            (sprintf "missing 'lambda lifting' information about function '%s'"
                            (id2str kf_name))
                        in
                    (prologue, [KDefFun make_kf; KDefClosureVars kcv])
                in
            (* add the generated prologue to the function body, then transform it alltogether *)
            let body_loc = get_kexp_loc kf_body in
            let body = code2kexp ((List.rev prologue) @ (kexp2code kf_body)) body_loc in
            let body = walk_kexp_n_lift_all body callb in
            defined_so_far := saved_dsf;
            curr_clo := saved_clo;
            curr_subst_env := saved_subst_env;
            curr_top_code := def_fcv_t_n_make @ !curr_top_code;
            kf := {!kf with kf_body=body};
            curr_top_code := (KDefFun kf) :: !curr_top_code;
            List.hd (create_defclosure kf [])
        | KDefVal(n, rhs, loc) ->
            let rhs = walk_kexp_n_lift_all rhs callb in
            let is_mutable_fvar = IdSet.mem n all_mut_fvars in
            defined_so_far := IdSet.add n !defined_so_far;
            if not is_mutable_fvar then
                KDefVal(n, rhs, loc)
            else
                let t = get_kexp_typ rhs in
                let ref_typ = KTypRef t in
                let nr =
                    match (Env.find_opt n !orig_subst_env) with
                    | Some ((_, nr)) -> nr
                    | _ -> raise_compile_err loc
                        (sprintf "k-lift: not found subst info about mutable free var '%s'" (id2str n))
                    in
                let (a, code) = match rhs with
                    | KExpAtom(a, _) -> (a, [])
                    | _ ->
                        let nr_arg = gen_temp_idk ((pp_id2str n) ^ "_arg") in
                        let {kv_scope} = get_kval n loc in
                        let code = create_kdefval nr_arg t [ValTemp] (Some rhs) [] kv_scope loc in
                        ((Atom.Id nr_arg), code)
                    in
                let code = KDefVal(nr, KExpUnOp(OpMkRef, a, (ref_typ, loc)), loc) :: code in
                let code = KDefVal(n, KExpUnOp(OpDeref, (Atom.Id nr), (t, loc)), loc) :: code in
                KExpSeq((List.rev code), (KTypVoid, loc))
        | KExpFor(idom_l, body, flags, loc) ->
            let idom_l = List.map (fun (i, dom_i) ->
                let dom_i = check_n_walk_dom dom_i loc callb in
                defined_so_far := IdSet.add i !defined_so_far;
                (i, dom_i)) idom_l in
            let body = walk_kexp_n_lift_all body callb in
            KExpFor(idom_l, body, flags, loc)
        | KExpMap(e_idom_ll, body, flags, ((etyp, eloc) as kctx)) ->
            let e_idom_ll = List.map (fun (e, idom_l) ->
                let e = walk_kexp_n_lift_all e callb in
                let idom_l = List.map (fun (i, dom_i) ->
                    let dom_i = check_n_walk_dom dom_i eloc callb in
                    defined_so_far := IdSet.add i !defined_so_far;
                    (i, dom_i)) idom_l
                in (e, idom_l)) e_idom_ll
            in let body = walk_kexp_n_lift_all body callb in
            KExpMap(e_idom_ll, body, flags, kctx)
        | KExpMkClosure(make_fp, f, args, (typ, loc)) ->
            let args = List.map (fun a -> walk_atom_n_lift_all_adv a loc true) args in
            KExpMkClosure(make_fp, f, args, (typ, loc))
        | KExpCall(f, args, ((_, loc) as kctx)) ->
            let args = List.map (fun a -> walk_atom_n_lift_all a loc callb) args in
            let (curr_f, curr_arg, curr_fvt_t) = !curr_clo in
            if f = curr_f then
                (*let cl_arg =
                    if curr_cl_arg = noid then Atom.Lit LitNil
                    else Atom.Id curr_cl_arg
                in KExpCall(f, args @ [cl_arg], kctx)*)
                KExpCall(f, args, kctx)
            else
                (match (kinfo_ f loc) with
                | KFun {contents={kf_closure={kci_fcv_t}}} ->
                    if kci_fcv_t = noid then
                        KExpCall(f, args, kctx)
                    else
                        KExpCall((check_n_walk_id f loc callb), args, kctx)
                | _ -> KExpCall((check_n_walk_id f loc callb), args, kctx))
        | _ -> walk_kexp e callb
    in let walk_n_lift_all_callb =
    {
        kcb_atom = Some(walk_atom_n_lift_all);
        kcb_typ = Some(walk_ktyp_n_lift_all);
        kcb_exp = Some(walk_kexp_n_lift_all)
    } in

    let top_code = make_wrappers_for_nothrow top_code in

    List.iter (fun e ->
        let e = walk_kexp_n_lift_all e walk_n_lift_all_callb in
        curr_top_code := e :: !curr_top_code) top_code;

    List.rev !curr_top_code
